// src/db_fields.ts
var TRANSACTION_ID_FIELD = "_xact_id";
var OBJECT_DELETE_FIELD = "_object_delete";
var CREATED_FIELD = "created";
var ID_FIELD = "id";
var IS_MERGE_FIELD = "_is_merge";
var MERGE_PATHS_FIELD = "_merge_paths";
var AUDIT_SOURCE_FIELD = "_audit_source";
var AUDIT_METADATA_FIELD = "_audit_metadata";
var VALID_SOURCES = ["app", "api", "external"];
var PARENT_ID_FIELD = "_parent_id";
var ASYNC_SCORING_CONTROL_FIELD = "_async_scoring_control";
var SKIP_ASYNC_SCORING_FIELD = "_skip_async_scoring";

// src/http_headers.ts
var BT_FOUND_EXISTING_HEADER = "x-bt-found-existing";
var BT_CURSOR_HEADER = "x-bt-cursor";
var BT_IMPERSONATE_USER = "x-bt-impersonate-user";

// src/type_util.ts
function isObject(value) {
  return value instanceof Object && !(value instanceof Array);
}
function isArray(value) {
  return value instanceof Array;
}
function isEmpty(a) {
  return a === void 0 || a === null;
}
function isNumber(a) {
  return typeof a === "number" || typeof a === "bigint";
}

// src/object_util.ts
function mergeDictsWithPaths({
  mergeInto,
  mergeFrom,
  mergePaths
}) {
  const mergePathsSerialized = new Set(
    mergePaths.map((p) => JSON.stringify(p))
  );
  return mergeDictsWithPathsHelper({
    mergeInto,
    mergeFrom,
    path: [],
    mergePaths: mergePathsSerialized
  });
}
function mergeDictsWithPathsHelper({
  mergeInto,
  mergeFrom,
  path,
  mergePaths
}) {
  Object.entries(mergeFrom).forEach(([k, mergeFromV]) => {
    const fullPath = path.concat([k]);
    const fullPathSerialized = JSON.stringify(fullPath);
    const mergeIntoV = recordFind(mergeInto, k);
    if (isObject(mergeIntoV) && isObject(mergeFromV) && !mergePaths.has(fullPathSerialized)) {
      mergeDictsWithPathsHelper({
        mergeInto: mergeIntoV,
        mergeFrom: mergeFromV,
        path: fullPath,
        mergePaths
      });
    } else {
      mergeInto[k] = mergeFromV;
    }
  });
  return mergeInto;
}
function mergeDicts(mergeInto, mergeFrom) {
  return mergeDictsWithPaths({ mergeInto, mergeFrom, mergePaths: [] });
}
function forEachMissingKey({
  lhs,
  rhs,
  fn
}) {
  function helper(lhs2, rhs2, path) {
    if (lhs2 instanceof Object) {
      if (!(rhs2 instanceof Object)) {
        return;
      }
      const lhsRec = lhs2;
      const rhsRec = rhs2;
      for (const [k, v] of Object.entries(rhsRec)) {
        if (!(k in lhsRec)) {
          fn({ lhs: lhsRec, k, v, path });
        } else {
          helper(lhsRec[k], rhsRec[k], [...path, k]);
        }
      }
    }
  }
  helper(lhs, rhs, []);
}
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}
function mapSetDefault(m, k, _default) {
  const ret = m.get(k);
  if (ret === void 0) {
    m.set(k, _default);
    return _default;
  } else {
    return ret;
  }
}
function mapSetNotPresent(m, k, v) {
  if (m.has(k)) {
    throw new Error(`Map already contains key ${k}`);
  }
  return m.set(k, v);
}
function recordFind(m, k) {
  return m[k];
}
function recordAt(m, k) {
  const ret = recordFind(m, k);
  if (ret === void 0) {
    throw new Error(`Record does not contain key ${String(k)}`);
  }
  return ret;
}
function recordSetDefault(m, k, _default) {
  const ret = recordFind(m, k);
  if (ret === void 0) {
    m[k] = _default;
    return _default;
  } else {
    return ret;
  }
}
function getRecordKeys(obj) {
  return Object.keys(obj);
}

// src/graph_util.ts
function depthFirstSearch(args) {
  var _a2;
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = (_a2 = args.visitationOrder) != null ? _a2 : [...graph.keys()];
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      lastVisitF == null ? void 0 : lastVisitF(vertex);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    firstVisitF == null ? void 0 : firstVisitF(vertex, { parentVertex: extras.parentVertex });
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = (vertex, args) => {
    const label = (args == null ? void 0 : args.parentVertex) !== void 0 ? mapAt(vertexLabels, args == null ? void 0 : args.parentVertex) : labelCounter++;
    vertexLabels.set(vertex, label);
  };
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = (vertex) => {
    reverseOrdering.push(vertex);
  };
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}

// src/merge_row_batch.ts
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      (useParentIdForId != null ? useParentIdForId : false) ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrust.dev for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
function batchItems(args) {
  var _a2, _b;
  let { items } = args;
  const batchMaxNumItems = (_a2 = args.batchMaxNumItems) != null ? _a2 : Number.POSITIVE_INFINITY;
  const batchMaxNumBytes = (_b = args.batchMaxNumBytes) != null ? _b : Number.POSITIVE_INFINITY;
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}

// src/object.ts
var DEFAULT_IS_LEGACY_DATASET = false;
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
function makeLegacyEvent(e) {
  if (!("dataset_id" in e) || !("expected" in e)) {
    return e;
  }
  const event = {
    ...e,
    output: e.expected
  };
  delete event.expected;
  if (MERGE_PATHS_FIELD in event) {
    for (const path of event[MERGE_PATHS_FIELD] || []) {
      if (path.length > 0 && path[0] === "expected") {
        path[0] = "output";
      }
    }
  }
  return event;
}

// src/json_util.ts
function deterministicReplacer(_key, value) {
  return value instanceof Object && !(value instanceof Array) ? Object.keys(value).sort().reduce((sorted, key) => {
    sorted[key] = value[key];
    return sorted;
  }, {}) : value;
}
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}

// src/string_util.ts
function _urljoin(...parts) {
  return parts.map(
    (x, i) => x.replace(/^\//, "").replace(i < parts.length - 1 ? /\/$/ : "", "")
  ).filter((x) => x.trim() !== "").join("/");
}
function capitalize(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toUpperCase() + s2.slice(1) : s2).join(sep || "");
}
function lowercase(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toLowerCase() + s2.slice(1) : s2).join(sep || "");
}
function snakeToCamelCase(s) {
  return s.split("_").map((s2) => capitalize(s2)).join("");
}
function snakeToTitleCase(s) {
  return capitalize(s, "_").replace("_", " ");
}
function camelToSnakeCase(s) {
  return s.replace(/([A-Z])/g, (m) => "_" + m.toLowerCase()).replace(/^_/, "");
}

// src/span_identifier_v1.ts
import * as uuid from "uuid";
import { z } from "zod";
function tryMakeUuid(s) {
  try {
    const ret = uuid.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER = 1;
var INVALID_ENCODING_ERRMSG = "SpanComponents string is not properly encoded. This may be due to a version mismatch between the SDK library used to export the span and the library used to decode it. Please make sure you are using the same SDK version across the board";
var SpanObjectTypeV1 = /* @__PURE__ */ ((SpanObjectTypeV12) => {
  SpanObjectTypeV12[SpanObjectTypeV12["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV12[SpanObjectTypeV12["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV12;
})(SpanObjectTypeV1 || {});
var SpanObjectTypeV1EnumSchema = z.nativeEnum(SpanObjectTypeV1);
var SpanRowIdsV1 = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponentsV1 = class _SpanComponentsV1 {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.rowIds = args.rowIds;
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER,
        this.objectType,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid(
      this.objectId
    );
    if (!objectIdIsUUID) {
      throw new Error("object_id component must be a valid UUID");
    }
    allBuffers.push(objectIdBytes);
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER) {
        throw new Error();
      }
      const objectType = SpanObjectTypeV1EnumSchema.parse(rawBytes[1]);
      if (![0, 1].includes(rawBytes[2])) {
        throw new Error();
      }
      if (![0, 1].includes(rawBytes[3])) {
        throw new Error();
      }
      const hasRowId = rawBytes[2] == 1;
      const rowIdIsUUID = rawBytes[3] == 1;
      const objectId = uuid.stringify(rawBytes.subarray(4, 20));
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        const spanId = uuid.stringify(rawBytes.subarray(20, 36));
        const rootSpanId = uuid.stringify(rawBytes.subarray(36, 52));
        const rowId = rowIdIsUUID ? uuid.stringify(rawBytes.subarray(52)) : rawBytes.subarray(52).toString("utf-8");
        return new SpanRowIdsV1({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponentsV1({ objectType, objectId, rowIds });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG);
    }
  }
  objectIdFields() {
    switch (this.objectType) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a2;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      rowIds: (_a2 = this.rowIds) == null ? void 0 : _a2.toObject()
    };
  }
};

// src/span_identifier_v2.ts
import * as uuid2 from "uuid";
import { z as z2 } from "zod";
function tryMakeUuid2(s) {
  try {
    const ret = uuid2.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER2 = 2;
var INVALID_ENCODING_ERRMSG2 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER2}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
var INTEGER_ENCODING_NUM_BYTES = 4;
var SpanObjectTypeV2 = /* @__PURE__ */ ((SpanObjectTypeV22) => {
  SpanObjectTypeV22[SpanObjectTypeV22["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV22[SpanObjectTypeV22["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV22;
})(SpanObjectTypeV2 || {});
var SpanObjectTypeV2EnumSchema = z2.nativeEnum(SpanObjectTypeV2);
var SpanRowIdsV2 = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponentsV2 = class _SpanComponentsV2 {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.computeObjectMetadataArgs = args.computeObjectMetadataArgs;
    this.rowIds = args.rowIds;
    if (!(this.objectId || this.computeObjectMetadataArgs)) {
      throw new Error(
        "Must provide either objectId or computeObjectMetadataArgs"
      );
    }
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid2(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER2,
        this.objectType,
        this.objectId ? 1 : 0,
        this.computeObjectMetadataArgs ? 1 : 0,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    if (this.objectId) {
      const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid2(
        this.objectId
      );
      if (!objectIdIsUUID) {
        throw new Error("object_id component must be a valid UUID");
      }
      allBuffers.push(objectIdBytes);
    }
    if (this.computeObjectMetadataArgs) {
      const computeObjectMetadataBytes = Buffer.from(
        JSON.stringify(this.computeObjectMetadataArgs),
        "utf-8"
      );
      const serializedLenBytes = Buffer.alloc(INTEGER_ENCODING_NUM_BYTES);
      serializedLenBytes.writeInt32BE(computeObjectMetadataBytes.length);
      allBuffers.push(serializedLenBytes, computeObjectMetadataBytes);
    }
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid2(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid2(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] < ENCODING_VERSION_NUMBER2) {
        const spanComponentsOld = SpanComponentsV1.fromStr(s);
        return new _SpanComponentsV2({
          objectType: SpanObjectTypeV2EnumSchema.parse(
            spanComponentsOld.objectType
          ),
          objectId: spanComponentsOld.objectId,
          rowIds: spanComponentsOld.rowIds ? new SpanRowIdsV2({
            rowId: spanComponentsOld.rowIds.rowId,
            spanId: spanComponentsOld.rowIds.spanId,
            rootSpanId: spanComponentsOld.rowIds.rootSpanId
          }) : void 0
        });
      }
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER2) {
        throw new Error();
      }
      const objectType = SpanObjectTypeV2EnumSchema.parse(rawBytes[1]);
      for (let i = 2; i < 6; ++i) {
        if (![0, 1].includes(rawBytes[i])) {
          throw new Error();
        }
      }
      const hasObjectId = rawBytes[2] == 1;
      const hasComputeObjectMetadataArgs = rawBytes[3] == 1;
      const hasRowId = rawBytes[4] == 1;
      const rowIdIsUUID = rawBytes[5] == 1;
      let byteCursor = 6;
      let objectId = void 0;
      if (hasObjectId) {
        const nextByteCursor = byteCursor + 16;
        objectId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
      }
      let computeObjectMetadataArgs;
      if (hasComputeObjectMetadataArgs) {
        let nextByteCursor = byteCursor + INTEGER_ENCODING_NUM_BYTES;
        const serializedLenBytes = rawBytes.readInt32BE(byteCursor);
        byteCursor = nextByteCursor;
        nextByteCursor = byteCursor + serializedLenBytes;
        computeObjectMetadataArgs = JSON.parse(
          rawBytes.subarray(byteCursor, nextByteCursor).toString("utf-8")
        );
        byteCursor = nextByteCursor;
      }
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        let nextByteCursor = byteCursor + 16;
        const spanId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
        nextByteCursor = byteCursor + 16;
        const rootSpanId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
        const rowId = rowIdIsUUID ? uuid2.stringify(rawBytes.subarray(byteCursor)) : rawBytes.subarray(byteCursor).toString("utf-8");
        return new SpanRowIdsV2({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponentsV2({
        objectType,
        objectId,
        computeObjectMetadataArgs,
        rowIds
      });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG2);
    }
  }
  objectIdFields() {
    if (!this.objectId) {
      throw new Error(
        "Impossible: cannot invoke `object_id_fields` unless SpanComponentsV2 is initialized with an `object_id`"
      );
    }
    switch (this.objectType) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a2;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      computeObjectMetadataArgs: this.computeObjectMetadataArgs,
      rowIds: (_a2 = this.rowIds) == null ? void 0 : _a2.toObject()
    };
  }
};

// src/span_identifier_v3.ts
import * as uuid3 from "uuid";
import { z as z3 } from "zod";
function tryMakeUuid3(s) {
  try {
    const ret = uuid3.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: void 0, isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER3 = 3;
var INVALID_ENCODING_ERRMSG3 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER3}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
var SpanObjectTypeV3 = /* @__PURE__ */ ((SpanObjectTypeV32) => {
  SpanObjectTypeV32[SpanObjectTypeV32["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV32[SpanObjectTypeV32["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV32;
})(SpanObjectTypeV3 || {});
var spanObjectTypeV3EnumSchema = z3.nativeEnum(SpanObjectTypeV3);
var InternalSpanComponentUUIDFields = /* @__PURE__ */ ((InternalSpanComponentUUIDFields2) => {
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["OBJECT_ID"] = 1] = "OBJECT_ID";
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROW_ID"] = 2] = "ROW_ID";
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["SPAN_ID"] = 3] = "SPAN_ID";
  InternalSpanComponentUUIDFields2[InternalSpanComponentUUIDFields2["ROOT_SPAN_ID"] = 4] = "ROOT_SPAN_ID";
  return InternalSpanComponentUUIDFields2;
})(InternalSpanComponentUUIDFields || {});
var internalSpanComponentUUIDFieldsEnumSchema = z3.nativeEnum(
  InternalSpanComponentUUIDFields
);
var _INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME = {
  [1 /* OBJECT_ID */]: "object_id",
  [2 /* ROW_ID */]: "row_id",
  [3 /* SPAN_ID */]: "span_id",
  [4 /* ROOT_SPAN_ID */]: "root_span_id"
};
var spanComponentsV3Schema = z3.object({
  object_type: spanObjectTypeV3EnumSchema,
  // TODO(manu): We should have a more elaborate zod schema for
  // `propagated_event`. This will required zod-ifying the contents of
  // sdk/core/js/src/object.ts.
  propagated_event: z3.record(z3.unknown()).nullish()
}).and(
  z3.union([
    // Must provide one or the other.
    z3.object({
      object_id: z3.string().nullish(),
      compute_object_metadata_args: z3.optional(z3.null())
    }),
    z3.object({
      object_id: z3.optional(z3.null()),
      compute_object_metadata_args: z3.record(z3.unknown())
    })
  ])
).and(
  z3.union([
    // Either all of these must be provided or none.
    z3.object({
      row_id: z3.string(),
      span_id: z3.string(),
      root_span_id: z3.string()
    }),
    z3.object({
      row_id: z3.optional(z3.null()),
      span_id: z3.optional(z3.null()),
      root_span_id: z3.optional(z3.null())
    })
  ])
);
var SpanComponentsV3 = class _SpanComponentsV3 {
  constructor(data) {
    this.data = data;
  }
  toStr() {
    const jsonObj = {
      compute_object_metadata_args: this.data.compute_object_metadata_args || void 0,
      propagated_event: this.data.propagated_event || void 0
    };
    const allBuffers = [];
    allBuffers.push(
      Buffer.from([ENCODING_VERSION_NUMBER3, this.data.object_type])
    );
    const uuidEntries = [];
    function addUuidField(origVal, fieldId) {
      const ret = tryMakeUuid3(origVal);
      if (ret.isUUID) {
        uuidEntries.push(Buffer.concat([Buffer.from([fieldId]), ret.bytes]));
      } else {
        jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = origVal;
      }
    }
    if (this.data.object_id) {
      addUuidField(
        this.data.object_id,
        1 /* OBJECT_ID */
      );
    }
    if (this.data.row_id) {
      addUuidField(this.data.row_id, 2 /* ROW_ID */);
    }
    if (this.data.span_id) {
      addUuidField(this.data.span_id, 3 /* SPAN_ID */);
    }
    if (this.data.root_span_id) {
      addUuidField(
        this.data.root_span_id,
        4 /* ROOT_SPAN_ID */
      );
    }
    if (uuidEntries.length > 255) {
      throw new Error("Impossible: too many UUID entries to encode");
    }
    allBuffers.push(Buffer.from([uuidEntries.length]));
    allBuffers.push(...uuidEntries);
    if (Object.keys(jsonObj).length > 0) {
      allBuffers.push(Buffer.from(JSON.stringify(jsonObj), "utf-8"));
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      const jsonObj = {};
      if (rawBytes[0] < ENCODING_VERSION_NUMBER3) {
        const spanComponentsOld = SpanComponentsV2.fromStr(s);
        jsonObj["object_type"] = spanComponentsOld.objectType;
        jsonObj["object_id"] = spanComponentsOld.objectId;
        jsonObj["compute_object_metadata_args"] = spanComponentsOld.computeObjectMetadataArgs;
        if (spanComponentsOld.rowIds) {
          jsonObj["row_id"] = spanComponentsOld.rowIds.rowId;
          jsonObj["span_id"] = spanComponentsOld.rowIds.spanId;
          jsonObj["root_span_id"] = spanComponentsOld.rowIds.rootSpanId;
        }
      } else {
        jsonObj["object_type"] = rawBytes[1];
        const numUuidEntries = rawBytes[2];
        let byteOffset = 3;
        for (let i = 0; i < numUuidEntries; ++i) {
          const fieldId = internalSpanComponentUUIDFieldsEnumSchema.parse(
            rawBytes[byteOffset]
          );
          const fieldBytes = rawBytes.subarray(byteOffset + 1, byteOffset + 17);
          byteOffset += 17;
          jsonObj[_INTERNAL_SPAN_COMPONENT_UUID_FIELDS_ID_TO_NAME[fieldId]] = uuid3.stringify(fieldBytes);
        }
        if (byteOffset < rawBytes.length) {
          const remainingJsonObj = JSON.parse(
            rawBytes.subarray(byteOffset).toString("utf-8")
          );
          Object.assign(jsonObj, remainingJsonObj);
        }
      }
      return _SpanComponentsV3.fromJsonObj(jsonObj);
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG3);
    }
  }
  objectIdFields() {
    if (!this.data.object_id) {
      throw new Error(
        "Impossible: cannot invoke `objectIdFields` unless SpanComponentsV3 is initialized with an `object_id`"
      );
    }
    switch (this.data.object_type) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.data.object_id };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.data.object_id, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  static fromJsonObj(jsonObj) {
    return new _SpanComponentsV3(spanComponentsV3Schema.parse(jsonObj));
  }
};

// src/span_types.ts
var spanTypeAttributeValues = [
  "llm",
  "score",
  "function",
  "eval",
  "task",
  "tool"
];
var SpanTypeAttribute = /* @__PURE__ */ ((SpanTypeAttribute2) => {
  SpanTypeAttribute2["LLM"] = "llm";
  SpanTypeAttribute2["SCORE"] = "score";
  SpanTypeAttribute2["FUNCTION"] = "function";
  SpanTypeAttribute2["EVAL"] = "eval";
  SpanTypeAttribute2["TASK"] = "task";
  SpanTypeAttribute2["TOOL"] = "tool";
  return SpanTypeAttribute2;
})(SpanTypeAttribute || {});
var spanPurposeAttributeValues = ["scorer"];

// typespecs/api_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi4 } from "@asteasolutions/zod-to-openapi";
import { z as z14 } from "zod";

// typespecs/app_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi3 } from "@asteasolutions/zod-to-openapi";
import { z as z13 } from "zod";

// src/zod_util.ts
import { z as z4 } from "zod";
var ExtraFieldsError = class extends Error {
  constructor(key, path) {
    super(
      `Extraneous key ${JSON.stringify(key)} at path ${JSON.stringify(path)}`
    );
    this.key = key;
    this.path = path;
  }
};
function parseNoStrip(schema, input) {
  const output = schema.parse(input);
  forEachMissingKey({
    lhs: output,
    rhs: input,
    fn: ({ k, path }) => {
      throw new ExtraFieldsError(k, path);
    }
  });
  return output;
}
function objectNullish(object) {
  return new z4.ZodObject({
    ...object._def,
    shape: () => Object.fromEntries(
      Object.entries(object.shape).map(([k, v]) => [k, v.nullish()])
    )
  });
}

// typespecs/common_types.ts
import { z as z5 } from "zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
extendZodWithOpenApi(z5);
var literalSchema = z5.union([
  z5.string().openapi({ title: "string" }),
  z5.number().openapi({ title: "number" }),
  z5.boolean().openapi({ title: "boolean" }),
  z5.null().openapi({ title: "null" })
]);
var jsonSchema = z5.lazy(
  () => z5.union([
    literalSchema,
    z5.array(jsonSchema).openapi({ title: "array" }),
    z5.record(jsonSchema).openapi({ title: "object" })
  ])
);
var datetimeStringSchema = z5.string().transform((x, ctx) => {
  const d = new Date(x);
  if (isNaN(d.getTime())) {
    ctx.addIssue({
      code: z5.ZodIssueCode.invalid_string,
      validation: "datetime",
      message: "Invalid datetime"
    });
    return z5.NEVER;
  }
  return d.toISOString();
}).openapi({ format: "date-time" });
var objectTypes = z5.enum([
  "project",
  "experiment",
  "dataset",
  "prompt",
  "prompt_session",
  "role",
  "group",
  "acl",
  "user",
  "project_score",
  "project_tag",
  "function",
  "view",
  "organization",
  "api_key",
  "ai_secret",
  "env_var"
]);
var objectTypesWithEvent = z5.enum([
  "project",
  "experiment",
  "dataset",
  "prompt",
  "function",
  "prompt_session"
]);
function getEventObjectType(objectType) {
  return objectType === "project" ? "project_logs" : objectType;
}
function getEventObjectDescription(objectType) {
  return getEventObjectType(objectType).replace("_", " ");
}
function getObjectArticle(objectType) {
  return [
    "acl",
    "api_key",
    "experiment",
    "organization",
    "ai_secret",
    "env_var"
  ].includes(objectType) ? "an" : "a";
}

// typespecs/custom_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi2 } from "@asteasolutions/zod-to-openapi";
import { z as z6 } from "zod";
extendZodWithOpenApi2(z6);
var modeSchema = z6.enum(["default", "stainless"]);
var _a;
var mode = modeSchema.parse(
  typeof process === "undefined" ? "default" : ((_a = process == null ? void 0 : process.env) == null ? void 0 : _a.BRAINTRUST_TYPESPECS_MODE) || "default"
);
var modeToTypes = {
  default: {
    unknown: z6.unknown(),
    literalTrue: z6.literal(true),
    literalFalse: z6.literal(false)
  },
  stainless: {
    // Stainless requires schemas which are completely permissive to be
    // tagged.
    unknown: z6.unknown().openapi({ ["x-stainless-any"]: true }),
    // Stainless does not support boolean literals in all SDKs.
    literalTrue: z6.boolean(),
    literalFalse: z6.boolean()
  }
};
var customTypes = modeToTypes[mode];

// typespecs/prompt.ts
import { z as z10 } from "zod";

// typespecs/openai/messages.ts
import { z as z7 } from "zod";
var messageRoleSchema = z7.enum([
  "system",
  "user",
  "assistant",
  "function",
  "tool",
  "model"
]);
var chatCompletionSystemMessageParamSchema = z7.object({
  content: z7.string().default(""),
  role: z7.literal("system"),
  name: z7.string().optional()
});
var chatCompletionContentPartTextSchema = z7.object({
  text: z7.string().default(""),
  type: z7.literal("text")
});
var imageURLSchema = z7.object({
  url: z7.string(),
  detail: z7.union([
    z7.literal("auto").openapi({ title: "auto" }),
    z7.literal("low").openapi({ title: "low" }),
    z7.literal("high").openapi({ title: "high" })
  ]).optional()
});
var chatCompletionContentPartImageSchema = z7.object({
  image_url: imageURLSchema,
  type: z7.literal("image_url")
});
var chatCompletionContentPartSchema = z7.union([
  chatCompletionContentPartTextSchema.openapi({ title: "text" }),
  chatCompletionContentPartImageSchema.openapi({ title: "image_url" })
]);
var chatCompletionContentSchema = z7.union([
  z7.string().default("").openapi({ title: "text" }),
  z7.array(
    chatCompletionContentPartSchema.openapi({
      title: "chat_completion_content_part"
    })
  ).openapi({ title: "array" })
]);
var chatCompletionUserMessageParamSchema = z7.object({
  content: chatCompletionContentSchema,
  role: z7.literal("user"),
  name: z7.string().optional()
});
var functionCallSchema = z7.object({
  arguments: z7.string(),
  name: z7.string()
});
var functionSchema = z7.object({
  arguments: z7.string(),
  name: z7.string()
});
var chatCompletionToolMessageParamSchema = z7.object({
  content: z7.string().default(""),
  role: z7.literal("tool"),
  tool_call_id: z7.string().default("")
});
var chatCompletionFunctionMessageParamSchema = z7.object({
  content: z7.string().default(""),
  name: z7.string(),
  role: z7.literal("function")
});
var chatCompletionMessageToolCallSchema = z7.object({
  id: z7.string(),
  function: functionSchema,
  type: z7.literal("function")
});
var chatCompletionAssistantMessageParamSchema = z7.object({
  role: z7.literal("assistant"),
  content: z7.string().nullish(),
  // NOTE: It's important to keep these optional, rather than nullish, to stay
  // inline with the OpenAI SDK's type definition.
  function_call: functionCallSchema.nullish().transform((x) => x != null ? x : void 0),
  name: z7.string().nullish().transform((x) => x != null ? x : void 0),
  tool_calls: z7.array(chatCompletionMessageToolCallSchema).nullish().transform((x) => x != null ? x : void 0)
});
var chatCompletionFallbackMessageParamSchema = z7.object({
  role: messageRoleSchema.exclude([
    "system",
    "user",
    "assistant",
    "tool",
    "function"
  ]),
  content: z7.string().nullish()
});
var chatCompletionOpenAIMessageParamSchema = z7.union([
  chatCompletionSystemMessageParamSchema.openapi({ title: "system" }),
  chatCompletionUserMessageParamSchema.openapi({ title: "user" }),
  chatCompletionAssistantMessageParamSchema.openapi({ title: "assistant" }),
  chatCompletionToolMessageParamSchema.openapi({ title: "tool" }),
  chatCompletionFunctionMessageParamSchema.openapi({ title: "function" })
]);
var chatCompletionMessageParamSchema = z7.union([
  chatCompletionOpenAIMessageParamSchema.openapi({ title: "openai" }),
  chatCompletionFallbackMessageParamSchema.openapi({ title: "fallback" })
]);

// typespecs/function_id.ts
import { z as z8 } from "zod";
var savedFunctionIdSchema = z8.union([
  z8.object({
    type: z8.literal("function"),
    id: z8.string()
  }).openapi({ title: "function" }),
  z8.object({
    type: z8.literal("global"),
    name: z8.string()
  }).openapi({ title: "global" })
]);
var extendedSavedFunctionIdSchema = savedFunctionIdSchema.or(
  z8.object({
    type: z8.literal("slug"),
    project_id: z8.string(),
    slug: z8.string()
  })
);

// typespecs/openai/tools.ts
import { z as z9 } from "zod";
var functionParametersSchema = z9.record(customTypes.unknown);
var functionDefinitionSchema = z9.object({
  name: z9.string(),
  description: z9.string().optional(),
  parameters: functionParametersSchema.optional()
});
var chatCompletionToolSchema = z9.object({
  function: functionDefinitionSchema,
  type: z9.literal("function")
});
var toolsSchema = z9.array(chatCompletionToolSchema);

// typespecs/prompt.ts
var promptBlockDataSchema = z10.union([
  z10.object({
    type: z10.literal("completion"),
    content: z10.string()
  }).openapi({ title: "completion" }),
  z10.object({
    type: z10.literal("chat"),
    messages: z10.array(chatCompletionMessageParamSchema),
    tools: z10.string().optional()
  }).openapi({ title: "chat" })
]);
var braintrustModelParamsSchema = z10.object({
  use_cache: z10.boolean().optional()
});
var BRAINTRUST_PARAMS = Object.keys(braintrustModelParamsSchema.shape);
var openAIModelParamsSchema = z10.object({
  temperature: z10.number().optional(),
  top_p: z10.number().optional(),
  max_tokens: z10.number().optional(),
  frequency_penalty: z10.number().optional(),
  presence_penalty: z10.number().optional(),
  response_format: z10.object({ type: z10.literal("json_object") }).nullish(),
  tool_choice: z10.union([
    z10.literal("auto").openapi({ title: "auto" }),
    z10.literal("none").openapi({ title: "none" }),
    z10.object({
      type: z10.literal("function"),
      function: z10.object({ name: z10.string() })
    }).openapi({ title: "function" })
  ]).optional(),
  function_call: z10.union([
    z10.literal("auto").openapi({ title: "auto" }),
    z10.literal("none").openapi({ title: "none" }),
    z10.object({
      name: z10.string()
    }).openapi({ title: "function" })
  ]).optional(),
  n: z10.number().optional(),
  stop: z10.array(z10.string()).optional()
});
var anthropicModelParamsSchema = z10.object({
  max_tokens: z10.number(),
  temperature: z10.number(),
  top_p: z10.number().optional(),
  top_k: z10.number().optional(),
  stop_sequences: z10.array(z10.string()).optional(),
  max_tokens_to_sample: z10.number().optional().describe("This is a legacy parameter that should not be used.")
});
var googleModelParamsSchema = z10.object({
  temperature: z10.number().optional(),
  maxOutputTokens: z10.number().optional(),
  topP: z10.number().optional(),
  topK: z10.number().optional()
});
var windowAIModelParamsSchema = z10.object({
  temperature: z10.number().optional(),
  topK: z10.number().optional()
});
var jsCompletionParamsSchema = z10.object({});
var modelParamsSchema = z10.union([
  braintrustModelParamsSchema.merge(openAIModelParamsSchema).passthrough().openapi({ title: "OpenAIModelParams" }),
  braintrustModelParamsSchema.merge(anthropicModelParamsSchema).passthrough().openapi({ title: "AnthropicModelParams" }),
  braintrustModelParamsSchema.merge(googleModelParamsSchema).passthrough().openapi({ title: "GoogleModelParams" }),
  braintrustModelParamsSchema.merge(windowAIModelParamsSchema).passthrough().openapi({ title: "WindowAIModelParams" }),
  braintrustModelParamsSchema.merge(jsCompletionParamsSchema).passthrough().openapi({ title: "JsCompletionParams" })
]);
var anyModelParamsSchema = openAIModelParamsSchema.merge(anthropicModelParamsSchema).merge(googleModelParamsSchema).merge(braintrustModelParamsSchema);
var promptOptionsSchema = z10.object({
  model: z10.string().optional(),
  params: modelParamsSchema.optional(),
  position: z10.string().optional()
});
var promptDataSchema = z10.object({
  prompt: promptBlockDataSchema.nullish(),
  options: promptOptionsSchema.nullish(),
  // This should be a union once we support multiple parser types
  parser: z10.object({
    type: z10.literal("llm_classifier"),
    use_cot: z10.boolean(),
    choice_scores: z10.record(z10.number().min(0).max(1))
  }).nullish(),
  tool_functions: z10.array(savedFunctionIdSchema).nullish(),
  origin: z10.object({
    prompt_id: z10.string().optional(),
    project_id: z10.string().optional(),
    prompt_version: z10.string().optional()
  }).nullish()
}).openapi("PromptData");

// typespecs/view.ts
import { z as z11 } from "zod";
var viewTypeEnum = z11.enum([
  "projects",
  "logs",
  "experiments",
  "datasets",
  "prompts",
  "playgrounds",
  "experiment",
  "dataset"
]).describe("Type of table that the view corresponds to.");
var viewDataSearchSchema = z11.object({
  filter: z11.array(customTypes.unknown).nullish(),
  tag: z11.array(customTypes.unknown).nullish(),
  match: z11.array(customTypes.unknown).nullish(),
  sort: z11.array(customTypes.unknown).nullish()
}).strip().openapi("ViewDataSearch");
var viewDataSchema = z11.object({
  search: viewDataSearchSchema.nullish()
}).strip().openapi("ViewData");
var viewOptionsSchema = z11.object({
  columnVisibility: z11.record(z11.boolean()).nullish(),
  columnOrder: z11.array(z11.string()).nullish(),
  columnSizing: z11.record(z11.number()).nullish()
}).strip().openapi("ViewOptions");

// typespecs/functions.ts
import { z as z12 } from "zod";
var validRuntimesEnum = z12.enum(["node", "python"]);
var functionTypeEnum = z12.enum(["llm", "scorer", "task", "tool"]);
var runtimeContextSchema = z12.object({
  runtime: validRuntimesEnum,
  version: z12.string()
});
var functionIdSchema = z12.union([
  z12.object({
    function_id: z12.string().describe("The ID of the function"),
    version: z12.string().optional().describe("The version of the function")
  }).describe("Function id"),
  z12.object({
    project_name: z12.string().describe("The name of the project containing the function"),
    slug: z12.string().describe("The slug of the function"),
    version: z12.string().optional().describe("The version of the function")
  }).describe("Project name and slug"),
  z12.object({
    global_function: z12.string().describe(
      "The name of the global function. Currently, the global namespace includes the functions in autoevals"
    )
  }).describe("Global function name"),
  z12.object({
    prompt_session_id: z12.string().describe("The ID of the prompt session"),
    prompt_session_function_id: z12.string().describe("The ID of the function in the prompt session"),
    version: z12.string().optional().describe("The version of the function")
  }).describe("Prompt session id"),
  z12.object({
    inline_context: runtimeContextSchema,
    code: z12.string().describe("The inline code to execute"),
    name: z12.string().nullish().describe("The name of the inline code function")
  }).describe("Inline code function"),
  z12.object({
    inline_prompt: promptDataSchema,
    name: z12.string().nullish().describe("The name of the inline prompt")
  }).describe("Inline prompt definition")
]).describe("Options for identifying a function");
var streamingModeEnum = z12.enum(["auto", "parallel"]);
var invokeFunctionNonIdArgsSchema = z12.object({
  input: customTypes.unknown.optional().describe(
    "Argument to the function, which can be any JSON serializable value"
  ),
  messages: z12.array(chatCompletionMessageParamSchema).optional().describe(
    "If the function is an LLM, additional messages to pass along to it"
  ),
  parent: z12.union([
    z12.object({
      object_type: z12.enum(["project_logs", "experiment"]),
      object_id: z12.string().describe("The id of the container object you are logging to"),
      row_ids: z12.object({
        id: z12.string().describe("The id of the row"),
        span_id: z12.string().describe("The span_id of the row"),
        root_span_id: z12.string().describe("The root_span_id of the row")
      }).nullish().describe("Identifiers for the row to to log a subspan under"),
      propagated_event: z12.record(customTypes.unknown).nullish().describe(
        "Include these properties in every span created under this parent"
      )
    }).describe("Span parent properties").openapi({ title: "span_parent_struct" }),
    z12.string().optional().describe(
      "The parent's span identifier, created by calling `.export()` on a span"
    )
  ]).describe("Options for tracing the function call"),
  stream: z12.boolean().nullish().describe(
    "Whether to stream the response. If true, results will be returned in the Braintrust SSE format."
  ),
  mode: streamingModeEnum.nullish().describe("The mode format of the returned value (defaults to 'auto')")
});
var invokeFunctionSchema = functionIdSchema.and(
  invokeFunctionNonIdArgsSchema
);
var invokeApiSchema = invokeFunctionNonIdArgsSchema.merge(
  z12.object({
    version: z12.string().optional().describe("The version of the function")
  })
).describe("The request to invoke a function");
var runEvalSchema = z12.object({
  project_id: z12.string().describe("Unique identifier for the project to run the eval in"),
  data: z12.union([
    z12.object({
      dataset_id: z12.string()
    }).describe("Dataset id"),
    z12.object({
      project_name: z12.string(),
      dataset_name: z12.string()
    }).describe("Project and dataset name")
  ]).describe("The dataset to use"),
  task: functionIdSchema.describe("The function to evaluate"),
  scores: z12.array(functionIdSchema).describe("The functions to score the eval on"),
  experiment_name: z12.string().optional().describe(
    "An optional name for the experiment created by this eval. If it conflicts with an existing experiment, it will be suffixed with a unique identifier."
  ),
  metadata: z12.record(customTypes.unknown).optional().describe(
    "Optional experiment-level metadata to store about the evaluation. You can later use this to slice & dice across experiments."
  ),
  stream: z12.boolean().optional().describe(
    "Whether to stream the results of the eval. If true, the request will return two events: one to indicate the experiment has started, and another upon completion. If false, the request will return the evaluation's summary upon completion."
  )
});
var baseSSEEventSchema = z12.object({
  id: z12.string().optional(),
  data: z12.string()
});
var sseTextEventSchema = baseSSEEventSchema.merge(
  z12.object({
    event: z12.literal("text_delta")
  })
);
var sseDataEventSchema = baseSSEEventSchema.merge(
  z12.object({
    event: z12.literal("json_delta")
  })
);
var sseErrorEventSchema = baseSSEEventSchema.merge(
  z12.object({
    event: z12.literal("error")
  })
);
var sseProgressEventSchema = baseSSEEventSchema.merge(
  z12.object({
    event: z12.literal("progress")
  })
);
var sseStartEventSchema = baseSSEEventSchema.omit({ data: true }).merge(
  z12.object({
    event: z12.literal("start"),
    data: z12.literal("")
  })
);
var sseDoneEventSchema = baseSSEEventSchema.omit({ data: true }).merge(
  z12.object({
    event: z12.literal("done"),
    data: z12.literal("")
  })
);
var functionObjectTypeEnum = z12.enum([
  "prompt",
  "tool",
  "scorer",
  "task"
]);
var functionFormatEnum = z12.enum(["llm", "code", "global"]);
var functionOutputTypeEnum = z12.enum(["completion", "score", "any"]);
var sseProgressEventDataSchema = z12.object({
  id: z12.string().describe("The id of the span this event is for"),
  object_type: functionObjectTypeEnum,
  format: functionFormatEnum,
  output_type: functionOutputTypeEnum,
  name: z12.string(),
  event: z12.enum(["text_delta", "json_delta", "error", "start", "done"]),
  data: z12.string()
  // This is the text_delta or json_delta
});
var callEventSchema = z12.union([
  sseTextEventSchema.openapi({ title: "text_delta" }),
  sseDataEventSchema.openapi({ title: "json_delta" }),
  sseProgressEventSchema.openapi({ title: "progress" }),
  sseErrorEventSchema.openapi({ title: "error" }),
  sseStartEventSchema.openapi({ title: "start" }),
  sseDoneEventSchema.openapi({ title: "done" })
]);
var scoreSchema = z12.union([
  z12.object({
    name: z12.string(),
    score: z12.number().min(0).max(1).nullable().default(null),
    // Sometimes we get an empty value over the wire
    metadata: z12.record(customTypes.unknown).optional().transform((data) => data != null ? data : void 0)
  }),
  z12.number().min(0).max(1),
  z12.boolean().transform((b) => b ? 1 : 0),
  z12.null()
]);
var ifExistsEnum = z12.enum(["error", "ignore", "replace"]);

// typespecs/app_types.ts
extendZodWithOpenApi3(z13);
function generateBaseTableSchema(objectName, opts) {
  let nameDescription = `Name of the ${objectName}`;
  if (opts == null ? void 0 : opts.uniqueName) {
    nameDescription += `. Within a project, ${objectName} names are unique`;
  }
  return z13.object({
    id: z13.string().uuid().describe(`Unique identifier for the ${objectName}`),
    project_id: z13.string().uuid().describe(
      `Unique identifier for the project that the ${objectName} belongs under`
    ),
    name: z13.string().describe(nameDescription),
    description: z13.string().nullish().describe(`Textual description of the ${objectName}`),
    created: datetimeStringSchema.nullish().describe(`Date of ${objectName} creation`),
    deleted_at: datetimeStringSchema.nullish().describe(
      `Date of ${objectName} deletion, or null if the ${objectName} is still active`
    ),
    user_id: z13.string().uuid().nullish().describe(`Identifies the user who created the ${objectName}`),
    metadata: z13.record(customTypes.unknown).nullish().describe(`User-controlled metadata about the ${objectName}`)
  });
}
var aclObjectTypeEnum = z13.enum([
  "organization",
  "project",
  "experiment",
  "dataset",
  "prompt",
  "prompt_session",
  "group",
  "role",
  "org_member",
  "project_log",
  "org_project"
]).describe("The object type that the ACL applies to");
var userBaseSchema = generateBaseTableSchema("user");
var userSchema = z13.object({
  id: userBaseSchema.shape.id,
  given_name: z13.string().nullish().describe("Given name of the user"),
  family_name: z13.string().nullish().describe("Family name of the user"),
  email: z13.string().nullish().describe("The user's email"),
  avatar_url: z13.string().nullish().describe("URL of the user's Avatar image"),
  created: userBaseSchema.shape.created
}).openapi("User");
var organizationBaseSchema = generateBaseTableSchema("organization");
var organizationSchema = z13.object({
  id: organizationBaseSchema.shape.id,
  name: organizationBaseSchema.shape.name,
  api_url: z13.string().nullish(),
  is_universal_api: z13.boolean().nullish(),
  proxy_url: z13.string().nullish(),
  realtime_url: z13.string().nullish(),
  created: organizationBaseSchema.shape.created
}).openapi("Organization");
var maxOverWindowSchema = z13.object({
  window_size_days: z13.number().int().positive(),
  max_value: z13.number().nonnegative()
}).openapi("MaxOverWindow");
var resourcesSchema = z13.object({
  org_id: organizationSchema.shape.id,
  forbid_toggle_experiment_public_to_private: z13.boolean().nullish(),
  num_private_experiment_row_actions: maxOverWindowSchema.nullish(),
  forbid_insert_datasets: z13.boolean().nullish(),
  forbid_insert_prompt_sessions: z13.boolean().nullish(),
  forbid_access_sql_explorer: z13.boolean().nullish(),
  num_production_log_row_actions: maxOverWindowSchema.nullish(),
  num_dataset_row_actions: maxOverWindowSchema.nullish()
}).openapi("Resources");
var memberSchema = z13.object({
  org_id: organizationSchema.shape.id,
  user_id: userSchema.shape.id
}).openapi("Member");
var aiSecretBaseSchema = generateBaseTableSchema("AI secret");
var aiSecretSchema = z13.object({
  id: aiSecretBaseSchema.shape.id,
  created: aiSecretBaseSchema.shape.created,
  org_id: organizationSchema.shape.id,
  name: aiSecretBaseSchema.shape.name,
  type: z13.string().nullish(),
  metadata: z13.record(customTypes.unknown).nullish(),
  preview_secret: z13.string().nullish()
}).openapi("AISecret");
var envVarObjectTypeEnum = z13.enum(["organization", "project", "function"]).describe("The type of the object the environment variable is scoped for");
var envVarBaseSchema = generateBaseTableSchema("environment variable");
var envVarSchema = z13.object({
  id: envVarBaseSchema.shape.id,
  object_type: envVarObjectTypeEnum,
  object_id: z13.string().uuid().describe("The id of the object the environment variable is scoped for"),
  name: z13.string().describe("The name of the environment variable"),
  created: envVarBaseSchema.shape.created,
  used: datetimeStringSchema.nullish().describe(`Date the environment variable was last used`)
}).openapi("EnvVar");
var apiKeyBaseSchema = generateBaseTableSchema("api key");
var apiKeySchema = z13.object({
  id: apiKeyBaseSchema.shape.id,
  created: apiKeyBaseSchema.shape.created,
  name: apiKeyBaseSchema.shape.name,
  preview_name: z13.string(),
  user_id: userSchema.shape.id.nullish(),
  org_id: organizationSchema.shape.id.nullish()
}).openapi("ApiKey");
var projectSettingsSchema = z13.object({
  comparison_key: z13.string().nullish().describe("The key used to join two experiments (defaults to `input`).")
});
var projectBaseSchema = generateBaseTableSchema("project");
var projectSchema = z13.object({
  id: projectBaseSchema.shape.id,
  org_id: z13.string().uuid().describe(
    "Unique id for the organization that the project belongs under"
  ),
  name: projectBaseSchema.shape.name,
  created: projectBaseSchema.shape.created,
  deleted_at: projectBaseSchema.shape.deleted_at,
  user_id: projectBaseSchema.shape.user_id,
  settings: projectSettingsSchema.nullish()
}).openapi("Project");
var datasetBaseSchema = generateBaseTableSchema("dataset", {
  uniqueName: true
});
var datasetSchema = z13.object({
  id: datasetBaseSchema.shape.id,
  project_id: datasetBaseSchema.shape.project_id.nullish(),
  name: datasetBaseSchema.shape.name,
  description: datasetBaseSchema.shape.description,
  created: datasetBaseSchema.shape.created,
  deleted_at: datasetBaseSchema.shape.deleted_at,
  user_id: datasetBaseSchema.shape.user_id,
  metadata: datasetBaseSchema.shape.metadata
}).openapi("Dataset");
var promptLogIdLiteralSchema = z13.literal("p").describe("A literal 'p' which identifies the object as a project prompt");
var promptBaseSchema = generateBaseTableSchema("prompt");
var promptSchemaObject = z13.object({
  id: promptBaseSchema.shape.id,
  // This has to be copy/pasted because zod blows up when there are circular dependencies
  _xact_id: z13.string().describe(
    `The transaction id of an event is unique to the network operation that processed the event insertion. Transaction ids are monotonically increasing over time and can be used to retrieve a versioned snapshot of the prompt (see the \`version\` parameter)`
  ),
  project_id: promptBaseSchema.shape.project_id,
  log_id: promptLogIdLiteralSchema,
  org_id: organizationSchema.shape.id,
  name: promptBaseSchema.shape.name,
  slug: z13.string().describe("Unique identifier for the prompt"),
  description: promptBaseSchema.shape.description,
  created: promptBaseSchema.shape.created,
  prompt_data: promptDataSchema.nullish().describe("The prompt, model, and its parameters"),
  tags: z13.array(z13.string()).nullish().describe("A list of tags for the prompt"),
  metadata: promptBaseSchema.shape.metadata,
  // An empty (unspecified) function_type is equivalent to "task".
  function_type: functionTypeEnum.nullish()
});
var promptSchema = promptSchemaObject.openapi("Prompt");
var codeBundleSchema = z13.object({
  runtime_context: runtimeContextSchema,
  location: z13.union([
    z13.object({
      type: z13.literal("experiment"),
      eval_name: z13.string(),
      position: z13.union([
        z13.object({ type: z13.literal("task") }),
        z13.object({
          type: z13.literal("scorer"),
          index: z13.number().int().nonnegative()
        }).openapi({ title: "scorer" })
      ])
    }).openapi({ title: "experiment" }),
    z13.object({
      type: z13.literal("function"),
      index: z13.number().int().nonnegative()
    }).openapi({ title: "function" })
  ]),
  bundle_id: z13.string(),
  preview: z13.string().nullish().describe("A preview of the code")
});
var functionDataSchema = z13.union([
  z13.object({
    type: z13.literal("prompt")
    // For backwards compatibility reasons, the prompt definition is hoisted out and stored
    // in the outer object
  }).openapi({ title: "prompt" }),
  z13.object({
    type: z13.literal("code"),
    data: z13.union([
      z13.object({
        type: z13.literal("bundle")
      }).and(codeBundleSchema).openapi({ title: "bundle" }),
      z13.object({
        type: z13.literal("inline"),
        runtime_context: runtimeContextSchema,
        code: z13.string()
      }).openapi({ title: "inline" })
    ])
  }).openapi({ title: "code" }),
  z13.object({
    type: z13.literal("global"),
    name: z13.string()
  }).openapi({ title: "global" })
]);
var functionSchema2 = promptSchemaObject.merge(
  z13.object({
    function_data: functionDataSchema,
    origin: z13.object({
      object_type: aclObjectTypeEnum,
      object_id: z13.string().uuid().describe("Id of the object the function is originating from"),
      internal: z13.boolean().nullish().describe(
        "The function exists for internal purposes and should not be displayed in the list of functions."
      )
    }).nullish(),
    function_schema: z13.object({
      parameters: customTypes.unknown,
      returns: customTypes.unknown.optional()
    }).nullish().describe("JSON schema for the function's parameters and return type")
  })
).openapi("Function");
var repoInfoSchema = z13.object({
  commit: z13.string().nullish().describe("SHA of most recent commit"),
  branch: z13.string().nullish().describe("Name of the branch the most recent commit belongs to"),
  tag: z13.string().nullish().describe("Name of the tag on the most recent commit"),
  dirty: z13.boolean().nullish().describe(
    "Whether or not the repo had uncommitted changes when snapshotted"
  ),
  author_name: z13.string().nullish().describe("Name of the author of the most recent commit"),
  author_email: z13.string().nullish().describe("Email of the author of the most recent commit"),
  commit_message: z13.string().nullish().describe("Most recent commit message"),
  commit_time: z13.string().nullish().describe("Time of the most recent commit"),
  git_diff: z13.string().nullish().describe(
    "If the repo was dirty when run, this includes the diff between the current state of the repo and the most recent commit."
  )
}).describe(
  "Metadata about the state of the repo when the experiment was created"
).openapi("RepoInfo");
var experimentBaseSchema = generateBaseTableSchema("experiment", {
  uniqueName: true
});
var experimentSchema = z13.object({
  id: experimentBaseSchema.shape.id,
  project_id: experimentBaseSchema.shape.project_id,
  name: experimentBaseSchema.shape.name,
  description: experimentBaseSchema.shape.description,
  created: experimentBaseSchema.shape.created,
  repo_info: repoInfoSchema.nullish(),
  commit: z13.string().nullish().describe("Commit, taken directly from `repo_info.commit`"),
  base_exp_id: z13.string().uuid().nullish().describe(
    "Id of default base experiment to compare against when viewing this experiment"
  ),
  deleted_at: experimentBaseSchema.shape.deleted_at,
  dataset_id: z13.string().uuid().nullish().describe(
    "Identifier of the linked dataset, or null if the experiment is not linked to a dataset"
  ),
  dataset_version: z13.string().nullish().describe(
    "Version number of the linked dataset the experiment was run against. This can be used to reproduce the experiment after the dataset has been modified."
  ),
  public: z13.boolean().describe(
    "Whether or not the experiment is public. Public experiments can be viewed by anybody inside or outside the organization"
  ),
  user_id: experimentBaseSchema.shape.user_id,
  metadata: experimentBaseSchema.shape.metadata
}).openapi("Experiment");
var promptSessionBaseSchema = generateBaseTableSchema("promptSession", {
  uniqueName: true
});
var promptSessionSchema = z13.object({
  id: promptSessionBaseSchema.shape.id,
  name: promptSessionBaseSchema.shape.name,
  description: promptSessionBaseSchema.shape.description,
  created: promptSessionBaseSchema.shape.created,
  deleted_at: promptSessionBaseSchema.shape.deleted_at,
  user_id: promptSessionBaseSchema.shape.user_id,
  project_id: promptSessionBaseSchema.shape.project_id,
  org_id: organizationSchema.shape.id.nullish().describe(
    "This field is deprecated and will be removed in a future revision"
  )
}).openapi("PromptSession");
var permissionEnum = z13.enum([
  "create",
  "read",
  "update",
  "delete",
  "create_acls",
  "read_acls",
  "update_acls",
  "delete_acls"
]).describe(
  [
    "Each permission permits a certain type of operation on an object in the system",
    "Permissions can be assigned to to objects on an individual basis, or grouped into roles"
  ].join("\n\n")
);
var roleBaseSchema = generateBaseTableSchema("role");
var roleSchema = z13.object({
  id: roleBaseSchema.shape.id,
  org_id: z13.string().uuid().nullish().describe(
    [
      "Unique id for the organization that the role belongs under",
      "A null org_id indicates a system role, which may be assigned to anybody and inherited by any other role, but cannot be edited.",
      "It is forbidden to change the org after creating a role"
    ].join("\n\n")
  ),
  user_id: roleBaseSchema.shape.user_id,
  created: roleBaseSchema.shape.created,
  name: roleBaseSchema.shape.name,
  description: roleBaseSchema.shape.description,
  deleted_at: roleBaseSchema.shape.deleted_at,
  member_permissions: z13.array(
    z13.object({
      permission: permissionEnum,
      restrict_object_type: aclObjectTypeEnum.nullish()
    })
  ).nullish().describe(
    "(permission, restrict_object_type) tuples which belong to this role"
  ),
  member_roles: z13.array(z13.string().uuid()).nullish().describe(
    [
      "Ids of the roles this role inherits from",
      "An inheriting role has all the permissions contained in its member roles, as well as all of their inherited permissions"
    ].join("\n\n")
  )
}).describe(
  [
    "A role is a collection of permissions which can be granted as part of an ACL",
    "Roles can consist of individual permissions, as well as a set of roles they inherit from"
  ].join("\n\n")
).openapi("Role");
var groupBaseSchema = generateBaseTableSchema("group");
var groupSchema = z13.object({
  id: groupBaseSchema.shape.id,
  org_id: z13.string().uuid().describe(
    [
      "Unique id for the organization that the group belongs under",
      "It is forbidden to change the org after creating a group"
    ].join("\n\n")
  ),
  user_id: groupBaseSchema.shape.user_id,
  created: groupBaseSchema.shape.created,
  name: groupBaseSchema.shape.name,
  description: groupBaseSchema.shape.description,
  deleted_at: groupBaseSchema.shape.deleted_at,
  member_users: z13.array(z13.string().uuid()).nullish().describe("Ids of users which belong to this group"),
  member_groups: z13.array(z13.string().uuid()).nullish().describe(
    [
      "Ids of the groups this group inherits from",
      "An inheriting group has all the users contained in its member groups, as well as all of their inherited users"
    ].join("\n\n")
  )
}).describe(
  [
    "A group is a collection of users which can be assigned an ACL",
    "Groups can consist of individual users, as well as a set of groups they inherit from"
  ].join("\n\n")
).openapi("Group");
var projectScoreTypeEnum = z13.enum(["slider", "categorical", "weighted", "minimum", "online"]).describe("The type of the configured score");
var projectScoreCategory = z13.object({
  name: z13.string().describe("Name of the category"),
  value: z13.number().describe(
    "Numerical value of the category. Must be between 0 and 1, inclusive"
  )
}).describe("For categorical-type project scores, defines a single category").openapi("ProjectScoreCategory");
var onlineScoreConfigSchema = z13.object({
  sampling_rate: z13.number().min(0).max(1).describe("The sampling rate for online scoring"),
  scorers: z13.array(savedFunctionIdSchema).describe("The list of scorers to use for online scoring"),
  apply_to_root_span: z13.boolean().nullish().describe(
    "Whether to trigger online scoring on the root span of each trace"
  ),
  apply_to_span_names: z13.string().array().nullish().describe("Trigger online scoring on any spans with a name in this list")
}).refine((val) => {
  var _a2;
  return val.apply_to_root_span || ((_a2 = val.apply_to_span_names) == null ? void 0 : _a2.length);
}, {
  message: "Online scoring rule does not apply to any rows"
}).openapi("OnlineScoreConfig");
var projectScoreBaseSchema = generateBaseTableSchema("project score");
var projectScoreSchema = z13.object({
  id: projectScoreBaseSchema.shape.id,
  project_id: projectScoreBaseSchema.shape.project_id,
  user_id: projectScoreBaseSchema.shape.user_id.unwrap().unwrap(),
  created: projectScoreBaseSchema.shape.created,
  name: projectScoreBaseSchema.shape.name,
  description: projectScoreBaseSchema.shape.description,
  score_type: projectScoreTypeEnum,
  categories: z13.union([
    projectScoreCategory.array().describe(
      "For categorical-type project scores, the list of all categories"
    ).openapi({ title: "categorical" }),
    z13.record(z13.number()).describe(
      "For weighted-type project scores, the weights of each score"
    ).openapi({ title: "weighted" }),
    z13.array(z13.string()).describe(
      "For minimum-type project scores, the list of included scores"
    ).openapi({ title: "minimum" })
  ]).nullish().openapi("ProjectScoreCategories"),
  config: z13.object({
    multi_select: z13.boolean().nullish(),
    destination: z13.literal("expected").nullish(),
    online: onlineScoreConfigSchema.nullish()
  }).nullish().openapi("ProjectScoreConfig"),
  position: z13.string().nullish().describe(
    "An optional LexoRank-based string that sets the sort position for the score in the UI"
  )
}).describe(
  "A project score is a user-configured score, which can be manually-labeled through the UI"
).openapi("ProjectScore");
var projectTagBaseSchema = generateBaseTableSchema("project tag");
var projectTagSchema = z13.object({
  id: projectTagBaseSchema.shape.id,
  project_id: projectTagBaseSchema.shape.project_id,
  user_id: projectTagBaseSchema.shape.user_id.unwrap().unwrap(),
  created: projectTagBaseSchema.shape.created,
  name: projectTagBaseSchema.shape.name,
  description: projectTagBaseSchema.shape.description,
  color: z13.string().nullish().describe("Color of the tag for the UI")
}).describe(
  "A project tag is a user-configured tag for tracking and filtering your experiments, logs, and other data"
).openapi("ProjectTag");
var viewBaseSchema = generateBaseTableSchema("view");
var viewSchema = z13.object({
  id: viewBaseSchema.shape.id,
  object_type: aclObjectTypeEnum,
  object_id: z13.string().uuid().describe("The id of the object the view applies to"),
  view_type: viewTypeEnum,
  name: viewBaseSchema.shape.name,
  created: viewBaseSchema.shape.created,
  view_data: viewDataSchema.nullish().describe("The view definition"),
  options: viewOptionsSchema.nullish().describe("Options for the view in the app"),
  user_id: viewBaseSchema.shape.user_id,
  deleted_at: roleBaseSchema.shape.deleted_at
}).openapi("View");
var aclBaseSchema = generateBaseTableSchema("acl");
var aclSchema = z13.object({
  id: aclBaseSchema.shape.id,
  object_type: aclObjectTypeEnum,
  object_id: z13.string().uuid().describe("The id of the object the ACL applies to"),
  user_id: z13.string().uuid().nullish().describe(
    "Id of the user the ACL applies to. Exactly one of `user_id` and `group_id` will be provided"
  ),
  group_id: z13.string().uuid().nullish().describe(
    "Id of the group the ACL applies to. Exactly one of `user_id` and `group_id` will be provided"
  ),
  permission: permissionEnum.nullish().describe(
    "Permission the ACL grants. Exactly one of `permission` and `role_id` will be provided"
  ),
  restrict_object_type: aclObjectTypeEnum.nullish().describe(
    "When setting a permission directly, optionally restricts the permission grant to just the specified object type. Cannot be set alongside a `role_id`."
  ),
  role_id: z13.string().uuid().nullish().describe(
    "Id of the role the ACL grants. Exactly one of `permission` and `role_id` will be provided"
  ),
  _object_org_id: z13.string().uuid().describe("The organization the ACL's referred object belongs to"),
  created: aclBaseSchema.shape.created
}).describe(
  [
    "An ACL grants a certain permission or role to a certain user or group on an object.",
    "ACLs are inherited across the object hierarchy. So for example, if a user has read permissions on a project, they will also have read permissions on any experiment, dataset, etc. created within that project.",
    "To restrict a grant to a particular sub-object, you may specify `restrict_object_type` in the ACL, as part of a direct permission grant or as part of a role."
  ].join("\n\n")
).openapi("Acl");
var appLimitSchema = z13.number().int().nonnegative().describe("Limit the number of objects to return");
function generateBaseTableOpSchema(objectName) {
  return z13.object({
    org_name: z13.string().nullish().describe(
      `For nearly all users, this parameter should be unnecessary. But in the rare case that your API key belongs to multiple organizations, you may specify the name of the organization the ${objectName} belongs in.`
    )
  });
}
var startingAfterSchema = z13.string().uuid().describe(
  [
    "Pagination cursor id.",
    "For example, if the final item in the last page you fetched had an id of `foo`, pass `starting_after=foo` to fetch the next page. Note: you may only pass one of `starting_after` and `ending_before`"
  ].join("\n\n")
).openapi("StartingAfter");
var endingBeforeSchema = z13.string().uuid().describe(
  [
    "Pagination cursor id.",
    "For example, if the initial item in the last page you fetched had an id of `foo`, pass `ending_before=foo` to fetch the previous page. Note: you may only pass one of `starting_after` and `ending_before`"
  ].join("\n\n")
).openapi("EndingBefore");
var createProjectBaseSchema = generateBaseTableOpSchema("project");
var createProjectSchema = z13.object({
  name: projectSchema.shape.name,
  org_name: createProjectBaseSchema.shape.org_name
}).openapi("CreateProject");
var patchProjectSchema = z13.object({
  name: projectSchema.shape.name.nullish(),
  settings: projectSchema.shape.settings.describe(
    "Project settings. Patch operations replace all settings, so make sure you include all settings you want to keep."
  ).nullish()
}).openapi("PatchProject");
var createExperimentSchema = z13.object({
  project_id: experimentSchema.shape.project_id,
  name: experimentSchema.shape.name.nullish(),
  description: experimentSchema.shape.description,
  repo_info: experimentSchema.shape.repo_info,
  base_exp_id: experimentSchema.shape.base_exp_id,
  dataset_id: experimentSchema.shape.dataset_id,
  dataset_version: experimentSchema.shape.dataset_version,
  public: experimentSchema.shape.public.nullish(),
  metadata: experimentSchema.shape.metadata,
  ensure_new: z13.boolean().nullish().describe(
    "Normally, creating an experiment with the same name as an existing experiment will return the existing one un-modified. But if `ensure_new` is true, registration will generate a new experiment with a unique name in case of a conflict."
  )
}).openapi("CreateExperiment");
var patchExperimentSchema = createExperimentSchema.omit({ project_id: true, ensure_new: true }).openapi("PatchExperiment");
var createDatasetSchema = z13.object({
  project_id: datasetSchema.shape.project_id,
  name: datasetSchema.shape.name,
  description: datasetSchema.shape.description
}).openapi("CreateDataset");
var patchDatasetSchema = z13.object({
  name: datasetSchema.shape.name.nullish(),
  description: datasetSchema.shape.description,
  metadata: datasetSchema.shape.metadata
}).openapi("PatchDataset");
var createPromptSchema = promptSchema.omit({
  id: true,
  _xact_id: true,
  org_id: true,
  log_id: true,
  created: true,
  metadata: true
}).openapi("CreatePrompt");
var createFunctionSchema = functionSchema2.omit({
  id: true,
  _xact_id: true,
  org_id: true,
  log_id: true,
  created: true,
  metadata: true
}).openapi("CreateFunction");
var patchPromptSchema = z13.object({
  name: promptSchema.shape.name.nullish(),
  slug: promptSchema.shape.slug.nullish(),
  description: promptSchema.shape.description.nullish(),
  prompt_data: promptSchema.shape.prompt_data.nullish(),
  tags: promptSchema.shape.tags.nullish()
}).openapi("PatchPrompt");
var patchFunctionSchema = z13.object({
  name: functionSchema2.shape.name.nullish(),
  description: functionSchema2.shape.description.nullish(),
  prompt_data: functionSchema2.shape.prompt_data.nullish(),
  function_data: functionSchema2.shape.function_data.nullish(),
  tags: functionSchema2.shape.tags.nullish()
}).openapi("PatchFunction");
var createRoleBaseSchema = generateBaseTableOpSchema("role");
var createRoleSchema = z13.object({
  name: roleSchema.shape.name,
  description: roleSchema.shape.description,
  member_permissions: roleSchema.shape.member_permissions,
  member_roles: roleSchema.shape.member_roles,
  org_name: createRoleBaseSchema.shape.org_name
}).openapi("CreateRole");
var patchRoleSchema = createRoleSchema.omit({
  name: true,
  org_name: true,
  member_permissions: true,
  member_roles: true
}).merge(
  z13.object({
    name: createRoleSchema.shape.name.nullish(),
    add_member_permissions: roleSchema.shape.member_permissions.nullish().describe("A list of permissions to add to the role"),
    remove_member_permissions: roleSchema.shape.member_permissions.nullish().describe("A list of permissions to remove from the role"),
    add_member_roles: roleSchema.shape.member_roles.nullish().describe(
      "A list of role IDs to add to the role's inheriting-from set"
    ),
    remove_member_roles: roleSchema.shape.member_roles.nullish().describe(
      "A list of role IDs to remove from the role's inheriting-from set"
    )
  })
).openapi("PatchRole");
var createGroupBaseSchema = generateBaseTableOpSchema("group");
var createGroupSchema = z13.object({
  name: groupSchema.shape.name,
  description: groupSchema.shape.description,
  member_users: groupSchema.shape.member_users,
  member_groups: groupSchema.shape.member_groups,
  org_name: createGroupBaseSchema.shape.org_name
}).openapi("CreateGroup");
var patchGroupSchema = createGroupSchema.omit({ name: true, org_name: true, member_users: true, member_groups: true }).merge(
  z13.object({
    name: createGroupSchema.shape.name.nullish(),
    add_member_users: groupSchema.shape.member_users.nullish().describe("A list of user IDs to add to the group"),
    remove_member_users: groupSchema.shape.member_users.nullish().describe("A list of user IDs to remove from the group"),
    add_member_groups: groupSchema.shape.member_groups.nullish().describe(
      "A list of group IDs to add to the group's inheriting-from set"
    ),
    remove_member_groups: groupSchema.shape.member_groups.nullish().describe(
      "A list of group IDs to remove from the group's inheriting-from set"
    )
  })
).openapi("PatchGroup");
var aclItemSchema = aclSchema.omit({
  id: true,
  created: true,
  _object_org_id: true
}).openapi("AclItem");
var aclBatchUpdateRequestSchema = z13.object({
  add_acls: aclItemSchema.array().nullish(),
  remove_acls: aclItemSchema.array().nullish()
});
var aclBatchUpdateResponseSchema = z13.object({
  added_acls: aclSchema.array(),
  removed_acls: aclSchema.array()
});
var createProjectScoreSchema = projectScoreSchema.pick({
  project_id: true,
  name: true,
  description: true,
  score_type: true,
  categories: true,
  config: true
}).openapi("CreateProjectScore");
var patchProjectScoreSchema = objectNullish(createProjectScoreSchema).omit({ project_id: true }).openapi("PatchProjectScore");
var createProjectTagSchema = z13.object({
  project_id: projectTagSchema.shape.project_id,
  name: projectTagSchema.shape.name,
  description: projectTagSchema.shape.description,
  color: projectTagSchema.shape.color
}).openapi("CreateProjectTag");
var patchProjectTagSchema = z13.object({
  name: projectTagSchema.shape.name.nullish(),
  description: projectTagSchema.shape.description,
  color: projectTagSchema.shape.color
}).openapi("PatchProjectTag");
var createViewSchema = viewSchema.omit({
  id: true,
  created: true
}).openapi("CreateView");
var patchViewSchema = z13.object({
  object_type: viewSchema.shape.object_type,
  object_id: viewSchema.shape.object_id,
  view_type: viewSchema.shape.view_type.nullish(),
  name: viewSchema.shape.name.nullish(),
  view_data: viewSchema.shape.view_data,
  options: viewSchema.shape.options,
  user_id: viewSchema.shape.user_id
}).openapi("PatchView");
var deleteViewSchema = z13.object({
  object_type: viewSchema.shape.object_type,
  object_id: viewSchema.shape.object_id
}).openapi("DeleteView");
var patchOrganizationSchema = z13.object({
  name: organizationSchema.shape.name.nullish(),
  api_url: organizationSchema.shape.api_url.nullish(),
  is_universal_api: organizationSchema.shape.is_universal_api.nullish(),
  proxy_url: organizationSchema.shape.proxy_url.nullish(),
  realtime_url: organizationSchema.shape.realtime_url.nullish()
}).openapi("PatchOrganization");
var createApiKeyBaseSchema = generateBaseTableOpSchema("API key");
var createApiKeySchema = z13.object({
  name: z13.string().describe("Name of the api key. Does not have to be unique"),
  org_name: createApiKeyBaseSchema.shape.org_name
});
var createApiKeyOutputSchema = apiKeySchema.merge(
  z13.object({
    key: z13.string().describe("The raw API key. It will only be exposed this one time")
  })
).openapi("CreateApiKeyOutput");
var organizationMembersSchema = z13.object({
  members: userSchema.pick({ id: true, email: true }).array()
}).openapi("OrganizationMembers");
var patchOrganizationMembersSchema = z13.object({
  invite_users: z13.object({
    ids: userSchema.shape.id.array().nullish().describe("Ids of existing users to invite"),
    emails: userSchema.shape.email.unwrap().unwrap().array().nullish().describe("Emails of users to invite"),
    send_invite_emails: z13.boolean().nullish().describe(
      "If true, send invite emails to the users who wore actually added"
    ),
    group_ids: groupSchema.shape.id.array().nullish().describe(
      "Optional list of group ids to add newly-invited users to."
    ),
    group_names: groupSchema.shape.name.array().nullish().describe(
      "Optional list of group names to add newly-invited users to."
    ),
    group_id: groupSchema.shape.id.nullish().describe("Singular form of group_ids"),
    group_name: groupSchema.shape.name.nullish().describe("Singular form of group_names")
  }).nullish().describe("Users to invite to the organization"),
  remove_users: z13.object({
    ids: userSchema.shape.id.array().nullish().describe("Ids of users to remove"),
    emails: userSchema.shape.email.unwrap().unwrap().array().nullish().describe("Emails of users to remove")
  }).nullish().describe("Users to remove from the organization"),
  org_name: z13.string().nullish().describe(
    `For nearly all users, this parameter should be unnecessary. But in the rare case that your API key belongs to multiple organizations, or in case you want to explicitly assert the organization you are modifying, you may specify the name of the organization.`
  ),
  org_id: z13.string().nullish().describe(
    `For nearly all users, this parameter should be unnecessary. But in the rare case that your API key belongs to multiple organizations, or in case you want to explicitly assert the organization you are modifying, you may specify the id of the organization.`
  )
}).openapi("PatchOrganizationMembers");
var patchOrganizationMembersOutputSchema = z13.object({
  status: z13.literal("success"),
  send_email_error: z13.string().nullish().describe(
    "If invite emails failed to send for some reason, the patch operation will still complete, but we will return an error message here"
  )
});
var createAISecretBaseSchema = generateBaseTableOpSchema("AI Secret");
var createAISecretSchema = z13.object({
  name: aiSecretSchema.shape.name,
  type: aiSecretSchema.shape.type,
  metadata: aiSecretSchema.shape.metadata,
  secret: z13.string().nullish().describe(
    "Secret value. If omitted in a PUT request, the existing secret value will be left intact, not replaced with null."
  ),
  org_name: createAISecretBaseSchema.shape.org_name
});
var deleteAISecretSchema = z13.object({
  name: aiSecretSchema.shape.name,
  org_name: createAISecretBaseSchema.shape.org_name
});
var patchAISecretSchema = z13.object({
  name: aiSecretSchema.shape.name.nullish(),
  type: aiSecretSchema.shape.type,
  metadata: aiSecretSchema.shape.metadata,
  secret: z13.string().nullish()
});
var createEnvVarSchema = envVarSchema.pick({ object_type: true, object_id: true, name: true }).extend({
  value: z13.string().nullish().describe(
    "The value of the environment variable. Will be encrypted at rest."
  )
});
var patchEnvVarSchema = envVarSchema.pick({ name: true }).extend({
  value: z13.string().nullish().describe(
    "The value of the environment variable. Will be encrypted at rest."
  )
});

// typespecs/api_types.ts
extendZodWithOpenApi4(z14);
var auditSourcesSchema = z14.enum(VALID_SOURCES);
function generateBaseEventOpSchema(objectType) {
  const eventDescription = getEventObjectDescription(objectType);
  return z14.object({
    id: z14.string().describe(
      `A unique identifier for the ${eventDescription} event. If you don't provide one, BrainTrust will generate one for you`
    ),
    [TRANSACTION_ID_FIELD]: z14.string().describe(
      `The transaction id of an event is unique to the network operation that processed the event insertion. Transaction ids are monotonically increasing over time and can be used to retrieve a versioned snapshot of the ${eventDescription} (see the \`version\` parameter)`
    ),
    created: datetimeStringSchema.describe(
      `The timestamp the ${eventDescription} event was created`
    ),
    input: customTypes.unknown,
    output: customTypes.unknown,
    expected: customTypes.unknown,
    error: customTypes.unknown.describe("The error that occurred, if any."),
    tags: z14.array(z14.string()).nullish().describe("A list of tags to log"),
    scores: z14.record(z14.number().min(0).max(1).nullish()).nullish(),
    metadata: z14.record(customTypes.unknown).nullish().describe(
      "A dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings"
    ),
    metrics: z14.object({
      start: z14.number().nullish().describe(
        `A unix timestamp recording when the section of code which produced the ${eventDescription} event started`
      ),
      end: z14.number().nullish().describe(
        `A unix timestamp recording when the section of code which produced the ${eventDescription} event finished`
      ),
      prompt_tokens: z14.number().int().nullish().describe(
        `The number of tokens in the prompt used to generate the ${eventDescription} event (only set if this is an LLM span)`
      ),
      completion_tokens: z14.number().int().nullish().describe(
        `The number of tokens in the completion generated by the model (only set if this is an LLM span)`
      ),
      tokens: z14.number().int().nullish().describe(
        `The total number of tokens in the input and output of the ${eventDescription} event.`
      )
    }).catchall(customTypes.unknown).nullish().describe(
      `Metrics are numerical measurements tracking the execution of the code that produced the ${eventDescription} event. Use "start" and "end" to track the time span over which the ${eventDescription} event was produced`
    ),
    context: z14.object({
      caller_functionname: z14.string().nullish().describe(
        `The function in code which created the ${eventDescription} event`
      ),
      caller_filename: z14.string().nullish().describe(
        `Name of the file in code where the ${eventDescription} event was created`
      ),
      caller_lineno: z14.number().int().nullish().describe(
        `Line of code where the ${eventDescription} event was created`
      )
    }).catchall(customTypes.unknown).nullish().describe(
      `Context is additional information about the code that produced the ${eventDescription} event. It is essentially the textual counterpart to \`metrics\`. Use the \`caller_*\` attributes to track the location in code which produced the ${eventDescription} event`
    ),
    span_id: z14.string().describe(
      `A unique identifier used to link different ${eventDescription} events together as part of a full trace. See the [tracing guide](https://www.braintrust.dev/docs/guides/tracing) for full details on tracing`
    ),
    span_parents: z14.string().array().nullish().describe(
      `An array of the parent \`span_ids\` of this ${eventDescription} event. This should be empty for the root span of a trace, and should most often contain just one parent element for subspans`
    ),
    root_span_id: z14.string().describe(
      `The \`span_id\` of the root of the trace this ${eventDescription} event belongs to`
    ),
    span_attributes: z14.object({
      name: z14.string().nullish().describe("Name of the span, for display purposes only"),
      type: z14.enum(spanTypeAttributeValues).nullish().describe("Type of the span, for display purposes only")
    }).catchall(customTypes.unknown).nullish().describe(
      "Human-identifying attributes of the span, such as name, type, etc."
    ),
    [OBJECT_DELETE_FIELD]: z14.boolean().nullish().describe(
      `Pass \`${OBJECT_DELETE_FIELD}=true\` to mark the ${eventDescription} event deleted. Deleted events will not show up in subsequent fetches for this ${eventDescription}`
    )
  });
}
function generateBaseEventFeedbackSchema(objectType) {
  const eventObjectType = getEventObjectType(objectType);
  const eventDescription = getEventObjectDescription(objectType);
  return z14.object({
    id: z14.string().describe(
      `The id of the ${eventDescription} event to log feedback for. This is the row \`id\` returned by \`POST /v1/${eventObjectType}/{${objectType}_id}/insert\``
    ),
    scores: z14.record(z14.number().min(0).max(1).nullish()).nullish().describe(
      `A dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the ${eventDescription} event`
    ),
    expected: customTypes.unknown.describe(
      "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not"
    ),
    tags: z14.array(z14.string()).nullish().describe("A list of tags to log"),
    comment: z14.string().nullish().describe(
      `An optional comment string to log about the ${eventDescription} event`
    ),
    metadata: z14.record(customTypes.unknown).nullish().describe(
      "A dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI."
    ),
    source: auditSourcesSchema.nullish().describe(
      'The source of the feedback. Must be one of "external" (default), "app", or "api"'
    )
  });
}
var fetchLimitSchema = z14.number().int().nonnegative().describe(
  [
    "limit the number of traces fetched",
    `Fetch queries may be paginated if the total result size is expected to be large (e.g. project_logs which accumulate over a long time). Note that fetch queries only support pagination in descending time order (from latest to earliest \`${TRANSACTION_ID_FIELD}\`. Furthermore, later pages may return rows which showed up in earlier pages, except with an earlier \`${TRANSACTION_ID_FIELD}\`. This happens because pagination occurs over the whole version history of the event log. You will most likely want to exclude any such duplicate, outdated rows (by \`id\`) from your combined result set.`,
    `The \`limit\` parameter controls the number of full traces to return. So you may end up with more individual rows than the specified limit if you are fetching events containing traces.`
  ].join("\n\n")
);
var fetchPaginationCursorDescription = [
  "DEPRECATION NOTICE: The manually-constructed pagination cursor is deprecated in favor of the explicit 'cursor' returned by object fetch requests. Please prefer the 'cursor' argument going forwards.",
  "Together, `max_xact_id` and `max_root_span_id` form a pagination cursor",
  `Since a paginated fetch query returns results in order from latest to earliest, the cursor for the next page can be found as the row with the minimum (earliest) value of the tuple \`(${TRANSACTION_ID_FIELD}, root_span_id)\`. See the documentation of \`limit\` for an overview of paginating fetch queries.`
].join("\n\n");
var maxXactIdSchema = z14.string().describe(fetchPaginationCursorDescription);
var maxRootSpanIdSchema = z14.string().describe(fetchPaginationCursorDescription);
var fetchPaginationCursorSchema = z14.string().describe(
  [
    "An opaque string to be used as a cursor for the next page of results, in order from latest to earliest.",
    "The string can be obtained directly from the `cursor` property of the previous fetch query"
  ].join("\n\n")
);
var versionSchema = z14.string().describe(
  [
    "Retrieve a snapshot of events from a past time",
    "The version id is essentially a filter on the latest event transaction id. You can use the `max_xact_id` returned by a past fetch as the version to reproduce that exact fetch."
  ].join("\n\n")
);
var pathTypeFilterSchema = z14.object({
  type: z14.literal("path_lookup").describe("Denotes the type of filter as a path-lookup filter"),
  path: z14.string().array().describe(
    'List of fields describing the path to the value to be checked against. For instance, if you wish to filter on the value of `c` in `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `path=["input", "a", "b", "c"]`'
  ),
  value: customTypes.unknown.describe(
    'The value to compare equality-wise against the event value at the specified `path`. The value must be a "primitive", that is, any JSON-serializable object except for objects and arrays. For instance, if you wish to filter on the value of "input.a.b.c" in the object `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `value="hello"`'
  )
}).describe(
  'A path-lookup filter describes an equality comparison against a specific sub-field in the event row. For instance, if you wish to filter on the value of `c` in `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `path=["input", "a", "b", "c"]` and `value="hello"`'
).openapi("PathLookupFilter");
var fetchFiltersSchema = pathTypeFilterSchema.array().describe(
  [
    "NOTE: This parameter is deprecated and will be removed in a future revision. Consider using the `/btql` endpoint (https://www.braintrust.dev/docs/reference/btql) for more advanced filtering.",
    "A list of filters on the events to fetch. Currently, only path-lookup type filters are supported."
  ].join("\n\n")
).openapi("FetchEventsFilters");
var fetchEventsRequestSchema = z14.object({
  limit: fetchLimitSchema.nullish(),
  cursor: fetchPaginationCursorSchema.nullish(),
  max_xact_id: maxXactIdSchema.nullish(),
  max_root_span_id: maxRootSpanIdSchema.nullish(),
  filters: fetchFiltersSchema.nullish(),
  version: versionSchema.nullish()
}).openapi("FetchEventsRequest");
function makeFetchEventsResponseSchema(objectType, eventSchema) {
  const eventName = capitalize(getEventObjectType(objectType), "_").replace(
    "_",
    ""
  );
  return z14.object({
    events: eventSchema.array().describe("A list of fetched events"),
    cursor: z14.string().nullish().describe(
      [
        "Pagination cursor",
        "Pass this string directly as the `cursor` param to your next fetch request to get the next page of results. Not provided if the returned result set is empty."
      ].join("\n\n")
    )
  }).openapi(`Fetch${eventName}EventsResponse`);
}
var experimentEventBaseSchema = generateBaseEventOpSchema("experiment");
var experimentEventSchema = z14.object({
  id: experimentEventBaseSchema.shape.id,
  dataset_record_id: z14.string().nullish().describe(
    "If the experiment is associated to a dataset, this is the event-level dataset id this experiment event is tied to"
  ),
  [TRANSACTION_ID_FIELD]: experimentEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: experimentEventBaseSchema.shape.created,
  project_id: experimentSchema.shape.project_id,
  experiment_id: experimentSchema.shape.id,
  input: experimentEventBaseSchema.shape.input.describe(
    "The arguments that uniquely define a test case (an arbitrary, JSON serializable object). Later on, Braintrust will use the `input` to know whether two test cases are the same between experiments, so they should not contain experiment-specific state. A simple rule of thumb is that if you run the same experiment twice, the `input` should be identical"
  ),
  output: experimentEventBaseSchema.shape.output.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question"
  ),
  expected: experimentEventBaseSchema.shape.expected.describe(
    "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate your experiments while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models"
  ),
  error: experimentEventBaseSchema.shape.error,
  scores: experimentEventBaseSchema.shape.scores.describe(
    "A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare experiments"
  ),
  metadata: experimentEventBaseSchema.shape.metadata,
  tags: experimentEventBaseSchema.shape.tags,
  metrics: experimentEventBaseSchema.shape.metrics,
  context: experimentEventBaseSchema.shape.context,
  span_id: experimentEventBaseSchema.shape.span_id,
  span_parents: experimentEventBaseSchema.shape.span_parents,
  root_span_id: experimentEventBaseSchema.shape.root_span_id,
  span_attributes: experimentEventBaseSchema.shape.span_attributes
}).openapi("ExperimentEvent");
var datasetEventBaseSchema = generateBaseEventOpSchema("dataset");
var datasetEventSchema = z14.object({
  id: datasetEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: datasetEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: datasetEventBaseSchema.shape.created,
  project_id: datasetSchema.shape.project_id,
  dataset_id: datasetSchema.shape.id,
  input: datasetEventBaseSchema.shape.input.describe(
    "The argument that uniquely define an input case (an arbitrary, JSON serializable object)"
  ),
  expected: datasetEventBaseSchema.shape.expected.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object)"
  ),
  metadata: datasetEventBaseSchema.shape.metadata,
  tags: datasetEventBaseSchema.shape.tags,
  span_id: datasetEventBaseSchema.shape.span_id,
  root_span_id: datasetEventBaseSchema.shape.root_span_id
}).openapi("DatasetEvent");
var promptSessionEventBaseSchema = generateBaseEventOpSchema("prompt_session");
var promptSessionEventSchema = z14.object({
  id: promptSessionEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: promptSessionEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: promptSessionEventBaseSchema.shape.created,
  project_id: promptSchema.shape.project_id,
  prompt_session_id: promptSchema.shape.id,
  prompt_session_data: customTypes.unknown.describe(
    "Data about the prompt session"
  ),
  prompt_data: customTypes.unknown.describe("Data about the prompt"),
  object_data: customTypes.unknown.describe("Data about the mapped data"),
  completion: customTypes.unknown.describe("Data about the completion"),
  tags: promptSessionEventBaseSchema.shape.tags
}).openapi("PromptSessionEvent");
var projectLogsEventBaseSchema = generateBaseEventOpSchema("project");
var projectLogsLogIdLiteralSchema = z14.literal("g").describe("A literal 'g' which identifies the log as a project log");
var projectLogsEventSchema = z14.object({
  id: projectLogsEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: projectLogsEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: projectLogsEventBaseSchema.shape.created,
  org_id: projectSchema.shape.org_id,
  project_id: projectSchema.shape.id,
  log_id: projectLogsLogIdLiteralSchema,
  input: projectLogsEventBaseSchema.shape.input.describe(
    "The arguments that uniquely define a user input (an arbitrary, JSON serializable object)."
  ),
  output: projectLogsEventBaseSchema.shape.output.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question."
  ),
  expected: projectLogsEventBaseSchema.shape.expected.describe(
    "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models."
  ),
  error: projectLogsEventBaseSchema.shape.error,
  scores: projectLogsEventBaseSchema.shape.scores.describe(
    "A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare logs."
  ),
  metadata: projectLogsEventBaseSchema.shape.metadata,
  tags: projectLogsEventBaseSchema.shape.tags,
  metrics: projectLogsEventBaseSchema.shape.metrics,
  context: projectLogsEventBaseSchema.shape.context,
  span_id: projectLogsEventBaseSchema.shape.span_id,
  span_parents: projectLogsEventBaseSchema.shape.span_parents,
  root_span_id: projectLogsEventBaseSchema.shape.root_span_id,
  span_attributes: projectLogsEventBaseSchema.shape.span_attributes
}).openapi("ProjectLogsEvent");
var isMergeDescription = [
  "The `_is_merge` field controls how the row is merged with any existing row with the same id in the DB. By default (or when set to `false`), the existing row is completely replaced by the new row. When set to `true`, the new row is deep-merged into the existing row",
  'For example, say there is an existing row in the DB `{"id": "foo", "input": {"a": 5, "b": 10}}`. If we merge a new row as `{"_is_merge": true, "id": "foo", "input": {"b": 11, "c": 20}}`, the new row will be `{"id": "foo", "input": {"a": 5, "b": 11, "c": 20}}`. If we replace the new row as `{"id": "foo", "input": {"b": 11, "c": 20}}`, the new row will be `{"id": "foo", "input": {"b": 11, "c": 20}}`'
].join("\n\n");
var mergeEventSchema = z14.object({
  [IS_MERGE_FIELD]: customTypes.literalTrue.describe(isMergeDescription),
  [MERGE_PATHS_FIELD]: z14.string().array().array().nullish().describe(
    [
      "The `_merge_paths` field allows controlling the depth of the merge. It can only be specified alongside `_is_merge=true`. `_merge_paths` is a list of paths, where each path is a list of field names. The deep merge will not descend below any of the specified merge paths.",
      'For example, say there is an existing row in the DB `{"id": "foo", "input": {"a": {"b": 10}, "c": {"d": 20}}, "output": {"a": 20}}`. If we merge a new row as `{"_is_merge": true, "_merge_paths": [["input", "a"], ["output"]], "input": {"a": {"q": 30}, "c": {"e": 30}, "bar": "baz"}, "output": {"d": 40}}`, the new row will be `{"id": "foo": "input": {"a": {"q": 30}, "c": {"d": 20, "e": 30}, "bar": "baz"}, "output": {"d": 40}}`. In this case, due to the merge paths, we have replaced `input.a` and `output`, but have still deep-merged `input` and `input.c`.'
    ].join("\n\n")
  )
});
var replacementEventSchema = z14.object({
  [IS_MERGE_FIELD]: customTypes.literalFalse.nullish().describe(isMergeDescription),
  [PARENT_ID_FIELD]: z14.string().nullish().describe(
    [
      "Use the `_parent_id` field to create this row as a subspan of an existing row. It cannot be specified alongside `_is_merge=true`. Tracking hierarchical relationships are important for tracing (see the [guide](https://www.braintrust.dev/docs/guides/tracing) for full details).",
      'For example, say we have logged a row `{"id": "abc", "input": "foo", "output": "bar", "expected": "boo", "scores": {"correctness": 0.33}}`. We can create a sub-span of the parent row by logging `{"_parent_id": "abc", "id": "llm_call", "input": {"prompt": "What comes after foo?"}, "output": "bar", "metrics": {"tokens": 1}}`. In the webapp, only the root span row `"abc"` will show up in the summary view. You can view the full trace hierarchy (in this case, the `"llm_call"` row) by clicking on the "abc" row.'
    ].join("\n\n")
  )
});
function makeInsertEventSchemas(objectType, insertSchema) {
  const eventDescription = getEventObjectDescription(objectType);
  const article = getObjectArticle(objectType);
  const eventSchemaName = capitalize(
    getEventObjectType(objectType),
    "_"
  ).replace("_", "");
  const replaceVariantSchema = insertSchema.merge(replacementEventSchema).openapi(`Insert${eventSchemaName}EventReplace`);
  const mergeVariantSchema = insertSchema.merge(mergeEventSchema).openapi(`Insert${eventSchemaName}EventMerge`);
  const eventSchema = z14.union([replaceVariantSchema, mergeVariantSchema]).describe(`${capitalize(article)} ${eventDescription} event`).openapi(`Insert${eventSchemaName}Event`);
  const requestSchema = z14.object({
    events: eventSchema.array().describe(`A list of ${eventDescription} events to insert`)
  }).openapi(`Insert${eventSchemaName}EventRequest`);
  return { eventSchema, requestSchema };
}
var insertEventsResponseSchema = z14.object({
  row_ids: z14.string().array().describe(
    "The ids of all rows that were inserted, aligning one-to-one with the rows provided as input"
  )
}).openapi("InsertEventsResponse");
var feedbackResponseSchema = z14.object({
  status: z14.literal("success")
}).openapi("FeedbackResponseSchema");
var insertExperimentEventBaseSchema = objectNullish(
  experimentEventSchema.pick({
    input: true,
    output: true,
    expected: true,
    error: true,
    scores: true,
    metadata: true,
    tags: true,
    metrics: true,
    context: true,
    span_attributes: true,
    id: true,
    dataset_record_id: true,
    created: true
  }).extend({
    [OBJECT_DELETE_FIELD]: experimentEventBaseSchema.shape[OBJECT_DELETE_FIELD]
  })
);
var {
  eventSchema: insertExperimentEventSchema,
  requestSchema: insertExperimentEventsRequestSchema
} = makeInsertEventSchemas("experiment", insertExperimentEventBaseSchema);
var insertDatasetEventBaseSchema = objectNullish(
  datasetEventSchema.pick({
    input: true,
    expected: true,
    metadata: true,
    tags: true,
    id: true,
    created: true
  }).extend({
    [OBJECT_DELETE_FIELD]: datasetEventBaseSchema.shape[OBJECT_DELETE_FIELD]
  })
);
var {
  eventSchema: insertDatasetEventSchema,
  requestSchema: insertDatasetEventsRequestSchema
} = makeInsertEventSchemas("dataset", insertDatasetEventBaseSchema);
var insertProjectLogsEventBaseSchema = objectNullish(
  projectLogsEventSchema.pick({
    input: true,
    output: true,
    expected: true,
    error: true,
    scores: true,
    metadata: true,
    tags: true,
    metrics: true,
    context: true,
    span_attributes: true,
    id: true,
    created: true
  }).extend({
    [OBJECT_DELETE_FIELD]: projectLogsEventBaseSchema.shape[OBJECT_DELETE_FIELD]
  })
);
var {
  eventSchema: insertProjectLogsEventSchema,
  requestSchema: insertProjectLogsEventsRequestSchema
} = makeInsertEventSchemas("project", insertProjectLogsEventBaseSchema);
function makeFeedbackRequestSchema(objectType, feedbackSchema) {
  const eventDescription = getEventObjectDescription(objectType);
  const eventSchemaName = capitalize(
    getEventObjectType(objectType),
    "_"
  ).replace("_", "");
  return z14.object({
    feedback: feedbackSchema.array().describe(`A list of ${eventDescription} feedback items`)
  }).openapi(`Feedback${eventSchemaName}EventRequest`);
}
var feedbackExperimentRequestBaseSchema = generateBaseEventFeedbackSchema("experiment");
var feedbackExperimentItemSchema = feedbackExperimentRequestBaseSchema.pick({
  id: true,
  scores: true,
  expected: true,
  comment: true,
  metadata: true,
  source: true
}).openapi("FeedbackExperimentItem");
var feedbackExperimentRequestSchema = makeFeedbackRequestSchema(
  "experiment",
  feedbackExperimentItemSchema
);
var feedbackDatasetRequestBaseSchema = generateBaseEventFeedbackSchema("dataset");
var feedbackDatasetItemSchema = feedbackDatasetRequestBaseSchema.pick({
  id: true,
  comment: true,
  metadata: true,
  source: true
}).openapi("FeedbackDatasetItem");
var feedbackDatasetRequestSchema = makeFeedbackRequestSchema(
  "dataset",
  feedbackDatasetItemSchema
);
var feedbackProjectLogsRequestBaseSchema = generateBaseEventFeedbackSchema("project");
var feedbackProjectLogsItemSchema = feedbackProjectLogsRequestBaseSchema.pick({
  id: true,
  scores: true,
  expected: true,
  comment: true,
  metadata: true,
  source: true
}).openapi("FeedbackProjectLogsItem");
var feedbackProjectLogsRequestSchema = makeFeedbackRequestSchema(
  "project",
  feedbackProjectLogsItemSchema
);
var apiSpecEventObjectSchemas = {
  experiment: {
    event: experimentEventSchema,
    fetchResponse: makeFetchEventsResponseSchema(
      "experiment",
      experimentEventSchema
    ),
    insertEvent: insertExperimentEventSchema,
    insertRequest: insertExperimentEventsRequestSchema,
    feedbackItem: feedbackExperimentItemSchema,
    feedbackRequest: feedbackExperimentRequestSchema
  },
  dataset: {
    event: datasetEventSchema,
    fetchResponse: makeFetchEventsResponseSchema("dataset", datasetEventSchema),
    insertEvent: insertDatasetEventSchema,
    insertRequest: insertDatasetEventsRequestSchema,
    feedbackItem: feedbackDatasetItemSchema,
    feedbackRequest: feedbackDatasetRequestSchema
  },
  project_logs: {
    event: projectLogsEventSchema,
    fetchResponse: makeFetchEventsResponseSchema(
      "project",
      projectLogsEventSchema
    ),
    insertEvent: insertProjectLogsEventSchema,
    insertRequest: insertProjectLogsEventsRequestSchema,
    feedbackItem: feedbackProjectLogsItemSchema,
    feedbackRequest: feedbackProjectLogsRequestSchema
  },
  prompt: {
    event: promptSchema
  },
  function: {
    event: functionSchema2
  },
  prompt_session: {}
};
function makeCrossObjectIndividualRequestSchema(objectType) {
  const eventObjectType = getEventObjectType(objectType);
  const eventDescription = getEventObjectDescription(objectType);
  const eventObjectSchema = apiSpecEventObjectSchemas[eventObjectType];
  const insertObject = z14.object({
    ...eventObjectSchema.insertEvent ? {
      events: eventObjectSchema.insertEvent.array().nullish().describe(`A list of ${eventDescription} events to insert`)
    } : {},
    ...eventObjectSchema.feedbackItem ? {
      feedback: eventObjectSchema.feedbackItem.array().nullish().describe(`A list of ${eventDescription} feedback items`)
    } : {}
  });
  return z14.record(z14.string().uuid(), insertObject).nullish().describe(
    `A mapping from ${objectType} id to a set of log events and feedback items to insert`
  );
}
function makeCrossObjectIndividualResponseSchema(objectType) {
  return z14.record(z14.string().uuid(), insertEventsResponseSchema).nullish().describe(
    `A mapping from ${objectType} id to row ids for inserted \`events\``
  );
}
var crossObjectInsertRequestSchema = z14.object({
  experiment: makeCrossObjectIndividualRequestSchema("experiment"),
  dataset: makeCrossObjectIndividualRequestSchema("dataset"),
  project_logs: makeCrossObjectIndividualRequestSchema("project")
}).openapi("CrossObjectInsertRequest");
var crossObjectInsertResponseSchema = z14.object({
  experiment: makeCrossObjectIndividualResponseSchema("experiment"),
  dataset: makeCrossObjectIndividualResponseSchema("dataset"),
  project_logs: makeCrossObjectIndividualResponseSchema("project")
}).openapi("CrossObjectInsertResponse");
var summarizeScoresParamSchema = z14.boolean().describe(
  "Whether to summarize the scores and metrics. If false (or omitted), only the metadata will be returned."
);
var comparisonExperimentIdParamSchema = z14.string().uuid().describe(
  "The experiment to compare against, if summarizing scores and metrics. If omitted, will fall back to the `base_exp_id` stored in the experiment metadata, and then to the most recent experiment run in the same project. Must pass `summarize_scores=true` for this id to be used"
);
var summarizeDataParamSchema = z14.boolean().describe(
  "Whether to summarize the data. If false (or omitted), only the metadata will be returned."
);
var summarizeExperimentResponseSchema = z14.object({
  project_name: z14.string().describe("Name of the project that the experiment belongs to"),
  experiment_name: z14.string().describe("Name of the experiment"),
  project_url: z14.string().url().describe("URL to the project's page in the Braintrust app"),
  experiment_url: z14.string().url().describe("URL to the experiment's page in the Braintrust app"),
  comparison_experiment_name: z14.string().nullish().describe("The experiment which scores are baselined against"),
  scores: z14.record(
    z14.object({
      name: z14.string().describe("Name of the score"),
      score: z14.number().min(0).max(1).describe("Average score across all examples"),
      diff: z14.number().min(-1).max(1).optional().describe(
        "Difference in score between the current and comparison experiment"
      ),
      improvements: z14.number().int().min(0).describe("Number of improvements in the score"),
      regressions: z14.number().int().min(0).describe("Number of regressions in the score")
    }).describe("Summary of a score's performance").openapi("ScoreSummary")
  ).nullish().describe("Summary of the experiment's scores"),
  metrics: z14.record(
    z14.object({
      name: z14.string().describe("Name of the metric"),
      metric: z14.number().describe("Average metric across all examples"),
      unit: z14.string().describe("Unit label for the metric"),
      diff: z14.number().optional().describe(
        "Difference in metric between the current and comparison experiment"
      ),
      improvements: z14.number().int().min(0).describe("Number of improvements in the metric"),
      regressions: z14.number().int().min(0).describe("Number of regressions in the metric")
    }).describe("Summary of a metric's performance").openapi("MetricSummary")
  ).nullish().describe("Summary of the experiment's metrics")
}).describe("Summary of an experiment").openapi("SummarizeExperimentResponse");
var summarizeDatasetResponseSchema = z14.object({
  project_name: z14.string().describe("Name of the project that the dataset belongs to"),
  dataset_name: z14.string().describe("Name of the dataset"),
  project_url: z14.string().url().describe("URL to the project's page in the Braintrust app"),
  dataset_url: z14.string().url().describe("URL to the dataset's page in the Braintrust app"),
  data_summary: z14.object({
    total_records: z14.number().int().min(0).describe("Total number of records in the dataset")
  }).nullish().describe("Summary of a dataset's data").openapi("DataSummary")
}).describe("Summary of a dataset").openapi("SummarizeDatasetResponse");
var asyncScoringStateSchema = z14.union([
  z14.object({
    status: z14.literal("enabled"),
    token: z14.string(),
    function_ids: z14.array(functionIdSchema).nonempty()
  }),
  // Explicitly disabled.
  z14.object({
    status: z14.literal("disabled")
  }),
  // Inactive but may be selected later.
  z14.null()
]);
var asyncScoringControlSchema = z14.discriminatedUnion("kind", [
  z14.object({
    kind: z14.literal("score_update"),
    token: z14.string()
  }),
  z14.object({
    kind: z14.literal("state_override"),
    state: asyncScoringStateSchema
  }),
  z14.object({
    kind: z14.literal("state_force_reselect")
  })
]);

// src/git_fields.ts
import { z as z15 } from "zod";
var gitFieldsSchema = repoInfoSchema.keyof();
var collectMetadataEnum = z15.enum(["all", "none", "some"]);
var gitMetadataSettingsSchema = z15.strictObject({
  collect: collectMetadataEnum,
  fields: z15.array(gitFieldsSchema).optional()
});
function mergeGitMetadataSettings(s1, s2) {
  var _a2;
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = ((_a2 = s1.fields) != null ? _a2 : []).filter((f) => {
    var _a3;
    return ((_a3 = s2.fields) != null ? _a3 : []).includes(f);
  });
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}

// src/xact-ids.ts
var TOP_BITS = BigInt("0x0DE1") << BigInt(48);
var MOD = BigInt(1) << BigInt(64);
var COPRIME = BigInt("205891132094649");
var COPRIME_INVERSE = BigInt("1522336535492693385");
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
function loadPrettyXact(encodedHex) {
  if (encodedHex.length !== 16) {
    return encodedHex;
  }
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}
export {
  ASYNC_SCORING_CONTROL_FIELD,
  AUDIT_METADATA_FIELD,
  AUDIT_SOURCE_FIELD,
  BT_CURSOR_HEADER,
  BT_FOUND_EXISTING_HEADER,
  BT_IMPERSONATE_USER,
  CREATED_FIELD,
  DEFAULT_IS_LEGACY_DATASET,
  ExtraFieldsError,
  ID_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD,
  PARENT_ID_FIELD,
  SKIP_ASYNC_SCORING_FIELD,
  SpanComponentsV1,
  SpanComponentsV2,
  SpanComponentsV3,
  SpanObjectTypeV1,
  SpanObjectTypeV2,
  SpanObjectTypeV3,
  SpanRowIdsV1,
  SpanRowIdsV2,
  SpanTypeAttribute,
  TRANSACTION_ID_FIELD,
  VALID_SOURCES,
  _urljoin,
  batchItems,
  camelToSnakeCase,
  capitalize,
  constructJsonArray,
  deterministicReplacer,
  ensureDatasetRecord,
  ensureLegacyDatasetRecord,
  ensureNewDatasetRecord,
  forEachMissingKey,
  getRecordKeys,
  gitFieldsSchema,
  gitMetadataSettingsSchema,
  isArray,
  isEmpty,
  isNumber,
  isObject,
  loadPrettyXact,
  lowercase,
  makeLegacyEvent,
  mapAt,
  mapSetDefault,
  mapSetNotPresent,
  mergeDicts,
  mergeDictsWithPaths,
  mergeGitMetadataSettings,
  mergeRowBatch,
  objectNullish,
  parseNoStrip,
  prettifyXact,
  recordAt,
  recordFind,
  recordSetDefault,
  snakeToCamelCase,
  snakeToTitleCase,
  spanComponentsV3Schema,
  spanObjectTypeV3EnumSchema,
  spanPurposeAttributeValues,
  spanTypeAttributeValues
};
