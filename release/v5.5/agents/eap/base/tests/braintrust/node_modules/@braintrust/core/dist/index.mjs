// src/db_fields.ts
var TRANSACTION_ID_FIELD = "_xact_id";
var OBJECT_DELETE_FIELD = "_object_delete";
var CREATED_FIELD = "created";
var ID_FIELD = "id";
var IS_MERGE_FIELD = "_is_merge";
var MERGE_PATHS_FIELD = "_merge_paths";
var AUDIT_SOURCE_FIELD = "_audit_source";
var AUDIT_METADATA_FIELD = "_audit_metadata";
var VALID_SOURCES = ["app", "api", "external"];
var PARENT_ID_FIELD = "_parent_id";
var ALL_ROW_ID_FIELDS = [
  ID_FIELD,
  TRANSACTION_ID_FIELD,
  CREATED_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD
];

// src/http_headers.ts
var BT_FOUND_EXISTING_HEADER = "x-bt-found-existing";
var BT_CURSOR_HEADER = "x-bt-cursor";
var BT_IMPERSONATE_USER = "x-bt-impersonate-user";

// src/util.ts
function mergeDicts(mergeInto, mergeFrom) {
  for (const [k, mergeFromV] of Object.entries(mergeFrom)) {
    const mergeIntoV = mergeInto[k];
    if (mergeIntoV instanceof Object && !Array.isArray(mergeIntoV) && mergeFrom instanceof Object && !Array.isArray(mergeFromV)) {
      mergeDicts(
        mergeIntoV,
        mergeFromV
      );
    } else {
      mergeInto[k] = mergeFromV;
    }
  }
  return mergeInto;
}
function forEachMissingKey({
  lhs,
  rhs,
  fn
}) {
  function helper(lhs2, rhs2, path) {
    if (lhs2 instanceof Object) {
      if (!(rhs2 instanceof Object)) {
        throw new Error(
          `Type mismatch between lhs and rhs object at path ${JSON.stringify(
            path
          )}`
        );
      }
      const lhsRec = lhs2;
      const rhsRec = rhs2;
      for (const [k, v] of Object.entries(rhsRec)) {
        if (!(k in lhsRec)) {
          fn({ lhs: lhsRec, k, v, path });
        } else {
          helper(lhsRec[k], rhsRec[k], [...path, k]);
        }
      }
    }
  }
  helper(lhs, rhs, []);
}
function capitalize(s, sep) {
  const items = sep ? s.split(sep) : [s];
  return items.map((s2) => s2 ? s2.charAt(0).toUpperCase() + s2.slice(1) : s2).join(sep || "");
}
function snakeToCamelCase(s) {
  return s.split("_").map((s2) => capitalize(s2)).join("");
}
function snakeToTitleCase(s) {
  return capitalize(s, "_").replace("_", " ");
}
function constructJsonArray(items) {
  return `[${items.join(",")}]`;
}
function mapAt(m, k) {
  const ret = m.get(k);
  if (ret === void 0) {
    throw new Error(`Map does not contain key ${k}`);
  }
  return ret;
}
function _urljoin(...parts) {
  return parts.map(
    (x, i) => x.replace(/^\//, "").replace(i < parts.length - 1 ? /\/$/ : "", "")
  ).filter((x) => x.trim() !== "").join("/");
}

// src/graph_util.ts
function depthFirstSearch(args) {
  var _a2;
  const { graph, firstVisitF, lastVisitF } = args;
  for (const vs of graph.values()) {
    for (const v of vs.values()) {
      if (!graph.has(v)) {
        throw new Error(`Outgoing vertex ${v} must be a key in the graph`);
      }
    }
  }
  const firstVisitedVertices = /* @__PURE__ */ new Set();
  const visitationOrder = (_a2 = args.visitationOrder) != null ? _a2 : [...graph.keys()];
  const events = visitationOrder.map((vertex) => ({ eventType: "first", vertex, extras: {} })).reverse();
  while (events.length) {
    const { eventType, vertex, extras } = events.pop();
    if (eventType === "last") {
      lastVisitF == null ? void 0 : lastVisitF(vertex);
      continue;
    }
    if (firstVisitedVertices.has(vertex)) {
      continue;
    }
    firstVisitedVertices.add(vertex);
    firstVisitF == null ? void 0 : firstVisitF(vertex, { parentVertex: extras.parentVertex });
    events.push({ eventType: "last", vertex, extras: {} });
    mapAt(graph, vertex).forEach((child) => {
      events.push({
        eventType: "first",
        vertex: child,
        extras: { parentVertex: vertex }
      });
    });
  }
}
function undirectedConnectedComponents(graph) {
  const directedGraph = new Map(
    [...graph.vertices].map((v) => [v, /* @__PURE__ */ new Set()])
  );
  for (const [i, j] of graph.edges) {
    mapAt(directedGraph, i).add(j);
    mapAt(directedGraph, j).add(i);
  }
  let labelCounter = 0;
  const vertexLabels = /* @__PURE__ */ new Map();
  const firstVisitF = (vertex, args) => {
    const label = (args == null ? void 0 : args.parentVertex) !== void 0 ? mapAt(vertexLabels, args == null ? void 0 : args.parentVertex) : labelCounter++;
    vertexLabels.set(vertex, label);
  };
  depthFirstSearch({ graph: directedGraph, firstVisitF });
  const output = Array.from({ length: labelCounter }).map(() => []);
  for (const [vertex, label] of vertexLabels.entries()) {
    output[label].push(vertex);
  }
  return output;
}
function topologicalSort(graph, visitationOrder) {
  const reverseOrdering = [];
  const lastVisitF = (vertex) => {
    reverseOrdering.push(vertex);
  };
  depthFirstSearch({ graph, lastVisitF, visitationOrder });
  return reverseOrdering.reverse();
}

// src/merge_row_batch.ts
function generateMergedRowKey(row, useParentIdForId) {
  return JSON.stringify(
    [
      "org_id",
      "project_id",
      "experiment_id",
      "dataset_id",
      "prompt_session_id",
      "log_id",
      (useParentIdForId != null ? useParentIdForId : false) ? PARENT_ID_FIELD : "id"
    ].map((k) => row[k])
  );
}
function mergeRowBatch(rows) {
  for (const row of rows) {
    if (row.id === void 0) {
      throw new Error(
        "Logged row is missing an id. This is an internal braintrust error. Please contact us at info@braintrust.dev for help"
      );
    }
  }
  const rowGroups = /* @__PURE__ */ new Map();
  for (const row of rows) {
    const key = generateMergedRowKey(row);
    const existingRow = rowGroups.get(key);
    if (existingRow !== void 0 && row[IS_MERGE_FIELD]) {
      const preserveNoMerge = !existingRow[IS_MERGE_FIELD];
      mergeDicts(existingRow, row);
      if (preserveNoMerge) {
        delete existingRow[IS_MERGE_FIELD];
      }
    } else {
      rowGroups.set(key, row);
    }
  }
  const merged = [...rowGroups.values()];
  const rowToLabel = new Map(
    merged.map((r, i) => [generateMergedRowKey(r), i])
  );
  const graph = new Map(
    Array.from({ length: merged.length }).map((_, i) => [i, /* @__PURE__ */ new Set()])
  );
  merged.forEach((r, i) => {
    const parentId = r[PARENT_ID_FIELD];
    if (!parentId) {
      return;
    }
    const parentRowKey = generateMergedRowKey(
      r,
      true
      /* useParentIdForId */
    );
    const parentLabel = rowToLabel.get(parentRowKey);
    if (parentLabel !== void 0) {
      mapAt(graph, parentLabel).add(i);
    }
  });
  const connectedComponents = undirectedConnectedComponents({
    vertices: new Set(graph.keys()),
    edges: new Set(
      [...graph.entries()].flatMap(
        ([k, vs]) => [...vs].map((v) => {
          const ret = [k, v];
          return ret;
        })
      )
    )
  });
  const buckets = connectedComponents.map(
    (cc) => topologicalSort(
      graph,
      cc
      /* visitationOrder */
    )
  );
  return buckets.map((bucket) => bucket.map((i) => merged[i]));
}
function batchItems(args) {
  var _a2, _b;
  let { items } = args;
  const batchMaxNumItems = (_a2 = args.batchMaxNumItems) != null ? _a2 : Number.POSITIVE_INFINITY;
  const batchMaxNumBytes = (_b = args.batchMaxNumBytes) != null ? _b : Number.POSITIVE_INFINITY;
  const output = [];
  let nextItems = [];
  let batchSet = [];
  let batch = [];
  let batchLen = 0;
  function addToBatch(item) {
    batch.push(item);
    batchLen += item.length;
  }
  function flushBatch() {
    batchSet.push(batch);
    batch = [];
    batchLen = 0;
  }
  while (items.length) {
    for (const bucket of items) {
      let i = 0;
      for (const item of bucket) {
        if (batch.length === 0 || item.length + batchLen < batchMaxNumBytes && batch.length < batchMaxNumItems) {
          addToBatch(item);
        } else if (i === 0) {
          flushBatch();
          addToBatch(item);
        } else {
          break;
        }
        ++i;
      }
      if (i < bucket.length) {
        nextItems.push(bucket.slice(i));
      }
      if (batchLen >= batchMaxNumBytes || batch.length > batchMaxNumItems) {
        flushBatch();
      }
    }
    if (batch.length) {
      flushBatch();
    }
    if (batchSet.length) {
      output.push(batchSet);
      batchSet = [];
    }
    items = nextItems;
    nextItems = [];
  }
  return output;
}

// src/object.ts
var DEFAULT_IS_LEGACY_DATASET = false;
function ensureDatasetRecord(r, legacy) {
  if (legacy) {
    return ensureLegacyDatasetRecord(r);
  } else {
    return ensureNewDatasetRecord(r);
  }
}
function ensureLegacyDatasetRecord(r) {
  if ("output" in r) {
    return r;
  }
  const row = {
    ...r,
    output: r.expected
  };
  delete row.expected;
  return row;
}
function ensureNewDatasetRecord(r) {
  if ("expected" in r) {
    return r;
  }
  const row = {
    ...r,
    tags: null,
    expected: r.output
  };
  delete row.output;
  return row;
}
function makeLegacyEvent(e) {
  if (!("dataset_id" in e) || !("expected" in e)) {
    return e;
  }
  const event = {
    ...e,
    output: e.expected
  };
  delete event.expected;
  if (MERGE_PATHS_FIELD in event) {
    for (const path of event[MERGE_PATHS_FIELD] || []) {
      if (path.length > 0 && path[0] === "expected") {
        path[0] = "output";
      }
    }
  }
  return event;
}

// src/span_identifier_v1.ts
import * as uuid from "uuid";
import { z } from "zod";
function tryMakeUuid(s) {
  try {
    const ret = uuid.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER = 1;
var INVALID_ENCODING_ERRMSG = "SpanComponents string is not properly encoded. This may be due to a version mismatch between the SDK library used to export the span and the library used to decode it. Please make sure you are using the same SDK version across the board";
var SpanObjectTypeV1 = /* @__PURE__ */ ((SpanObjectTypeV12) => {
  SpanObjectTypeV12[SpanObjectTypeV12["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV12[SpanObjectTypeV12["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV12;
})(SpanObjectTypeV1 || {});
var SpanObjectTypeV1EnumSchema = z.nativeEnum(SpanObjectTypeV1);
var SpanRowIdsV1 = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponentsV1 = class _SpanComponentsV1 {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.rowIds = args.rowIds;
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER,
        this.objectType,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid(
      this.objectId
    );
    if (!objectIdIsUUID) {
      throw new Error("object_id component must be a valid UUID");
    }
    allBuffers.push(objectIdBytes);
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER) {
        throw new Error();
      }
      const objectType = SpanObjectTypeV1EnumSchema.parse(rawBytes[1]);
      if (![0, 1].includes(rawBytes[2])) {
        throw new Error();
      }
      if (![0, 1].includes(rawBytes[3])) {
        throw new Error();
      }
      const hasRowId = rawBytes[2] == 1;
      const rowIdIsUUID = rawBytes[3] == 1;
      const objectId = uuid.stringify(rawBytes.subarray(4, 20));
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        const spanId = uuid.stringify(rawBytes.subarray(20, 36));
        const rootSpanId = uuid.stringify(rawBytes.subarray(36, 52));
        const rowId = rowIdIsUUID ? uuid.stringify(rawBytes.subarray(52)) : rawBytes.subarray(52).toString("utf-8");
        return new SpanRowIdsV1({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponentsV1({ objectType, objectId, rowIds });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG);
    }
  }
  objectIdFields() {
    switch (this.objectType) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a2;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      rowIds: (_a2 = this.rowIds) == null ? void 0 : _a2.toObject()
    };
  }
};

// src/span_identifier_v2.ts
import * as uuid2 from "uuid";
import { z as z2 } from "zod";
function tryMakeUuid2(s) {
  try {
    const ret = uuid2.parse(s);
    if (ret.length !== 16) {
      throw new Error();
    }
    return { bytes: Buffer.from(ret), isUUID: true };
  } catch (e) {
    return { bytes: Buffer.from(s, "utf-8"), isUUID: false };
  }
}
var ENCODING_VERSION_NUMBER2 = 2;
var INVALID_ENCODING_ERRMSG2 = `SpanComponents string is not properly encoded. This library only supports encoding versions up to ${ENCODING_VERSION_NUMBER2}. Please make sure the SDK library used to decode the SpanComponents is at least as new as any library used to encode it.`;
var INTEGER_ENCODING_NUM_BYTES = 4;
var SpanObjectTypeV2 = /* @__PURE__ */ ((SpanObjectTypeV22) => {
  SpanObjectTypeV22[SpanObjectTypeV22["EXPERIMENT"] = 1] = "EXPERIMENT";
  SpanObjectTypeV22[SpanObjectTypeV22["PROJECT_LOGS"] = 2] = "PROJECT_LOGS";
  return SpanObjectTypeV22;
})(SpanObjectTypeV2 || {});
var SpanObjectTypeV2EnumSchema = z2.nativeEnum(SpanObjectTypeV2);
var SpanRowIdsV2 = class {
  constructor(args) {
    this.rowId = args.rowId;
    this.spanId = args.spanId;
    this.rootSpanId = args.rootSpanId;
    if (!this.rowId) {
      throw new Error("rowId must be nonempty string");
    }
    if (!this.spanId) {
      throw new Error("spanId must be nonempty string");
    }
    if (!this.rootSpanId) {
      throw new Error("rootSpanId must be nonempty string");
    }
  }
  toObject() {
    return {
      rowId: this.rowId,
      spanId: this.spanId,
      rootSpanId: this.rootSpanId
    };
  }
};
var SpanComponentsV2 = class _SpanComponentsV2 {
  constructor(args) {
    this.objectType = args.objectType;
    this.objectId = args.objectId;
    this.computeObjectMetadataArgs = args.computeObjectMetadataArgs;
    this.rowIds = args.rowIds;
    if (!(this.objectId || this.computeObjectMetadataArgs)) {
      throw new Error(
        "Must provide either objectId or computeObjectMetadataArgs"
      );
    }
  }
  toStr() {
    const allBuffers = [];
    const { bytes: rowIdBytes, isUUID: rowIdIsUUID } = this.rowIds ? tryMakeUuid2(this.rowIds.rowId) : { bytes: Buffer.from(""), isUUID: false };
    allBuffers.push(
      Buffer.from([
        ENCODING_VERSION_NUMBER2,
        this.objectType,
        this.objectId ? 1 : 0,
        this.computeObjectMetadataArgs ? 1 : 0,
        this.rowIds ? 1 : 0,
        rowIdIsUUID ? 1 : 0
      ])
    );
    if (this.objectId) {
      const { bytes: objectIdBytes, isUUID: objectIdIsUUID } = tryMakeUuid2(
        this.objectId
      );
      if (!objectIdIsUUID) {
        throw new Error("object_id component must be a valid UUID");
      }
      allBuffers.push(objectIdBytes);
    }
    if (this.computeObjectMetadataArgs) {
      const computeObjectMetadataBytes = Buffer.from(
        JSON.stringify(this.computeObjectMetadataArgs),
        "utf-8"
      );
      const serializedLenBytes = Buffer.alloc(INTEGER_ENCODING_NUM_BYTES);
      serializedLenBytes.writeInt32BE(computeObjectMetadataBytes.length);
      allBuffers.push(serializedLenBytes, computeObjectMetadataBytes);
    }
    if (this.rowIds) {
      const { bytes: spanIdBytes, isUUID: spanIdIsUUID } = tryMakeUuid2(
        this.rowIds.spanId
      );
      if (!spanIdIsUUID) {
        throw new Error("span_id component must be a valid UUID");
      }
      const { bytes: rootSpanIdBytes, isUUID: rootSpanIdIsUUID } = tryMakeUuid2(
        this.rowIds.rootSpanId
      );
      if (!rootSpanIdIsUUID) {
        throw new Error("root_span_id component must be a valid UUID");
      }
      allBuffers.push(spanIdBytes, rootSpanIdBytes, rowIdBytes);
    }
    return Buffer.concat(allBuffers).toString("base64");
  }
  static fromStr(s) {
    try {
      const rawBytes = Buffer.from(s, "base64");
      if (rawBytes[0] < ENCODING_VERSION_NUMBER2) {
        const spanComponentsOld = SpanComponentsV1.fromStr(s);
        return new _SpanComponentsV2({
          objectType: SpanObjectTypeV2EnumSchema.parse(
            spanComponentsOld.objectType
          ),
          objectId: spanComponentsOld.objectId,
          rowIds: spanComponentsOld.rowIds ? new SpanRowIdsV2({
            rowId: spanComponentsOld.rowIds.rowId,
            spanId: spanComponentsOld.rowIds.spanId,
            rootSpanId: spanComponentsOld.rowIds.rootSpanId
          }) : void 0
        });
      }
      if (rawBytes[0] !== ENCODING_VERSION_NUMBER2) {
        throw new Error();
      }
      const objectType = SpanObjectTypeV2EnumSchema.parse(rawBytes[1]);
      for (let i = 2; i < 6; ++i) {
        if (![0, 1].includes(rawBytes[i])) {
          throw new Error();
        }
      }
      const hasObjectId = rawBytes[2] == 1;
      const hasComputeObjectMetadataArgs = rawBytes[3] == 1;
      const hasRowId = rawBytes[4] == 1;
      const rowIdIsUUID = rawBytes[5] == 1;
      let byteCursor = 6;
      let objectId = void 0;
      if (hasObjectId) {
        const nextByteCursor = byteCursor + 16;
        objectId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
      }
      let computeObjectMetadataArgs;
      if (hasComputeObjectMetadataArgs) {
        let nextByteCursor = byteCursor + INTEGER_ENCODING_NUM_BYTES;
        const serializedLenBytes = rawBytes.readInt32BE(byteCursor);
        byteCursor = nextByteCursor;
        nextByteCursor = byteCursor + serializedLenBytes;
        computeObjectMetadataArgs = JSON.parse(
          rawBytes.subarray(byteCursor, nextByteCursor).toString("utf-8")
        );
        byteCursor = nextByteCursor;
      }
      const rowIds = (() => {
        if (!hasRowId) {
          return void 0;
        }
        let nextByteCursor = byteCursor + 16;
        const spanId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
        nextByteCursor = byteCursor + 16;
        const rootSpanId = uuid2.stringify(
          rawBytes.subarray(byteCursor, nextByteCursor)
        );
        byteCursor = nextByteCursor;
        const rowId = rowIdIsUUID ? uuid2.stringify(rawBytes.subarray(byteCursor)) : rawBytes.subarray(byteCursor).toString("utf-8");
        return new SpanRowIdsV2({ rowId, spanId, rootSpanId });
      })();
      return new _SpanComponentsV2({
        objectType,
        objectId,
        computeObjectMetadataArgs,
        rowIds
      });
    } catch (e) {
      throw new Error(INVALID_ENCODING_ERRMSG2);
    }
  }
  objectIdFields() {
    if (!this.objectId) {
      throw new Error(
        "Impossible: cannot invoke `object_id_fields` unless SpanComponentsV2 is initialized with an `object_id`"
      );
    }
    switch (this.objectType) {
      case 1 /* EXPERIMENT */:
        return { experiment_id: this.objectId };
      case 2 /* PROJECT_LOGS */:
        return { project_id: this.objectId, log_id: "g" };
      default:
        throw new Error("Impossible");
    }
  }
  toObject() {
    var _a2;
    return {
      objectType: this.objectType,
      objectId: this.objectId,
      computeObjectMetadataArgs: this.computeObjectMetadataArgs,
      rowIds: (_a2 = this.rowIds) == null ? void 0 : _a2.toObject()
    };
  }
};

// src/span_types.ts
var spanTypeAttributeValues = [
  "llm",
  "score",
  "function",
  "eval",
  "task",
  "tool"
];
var SpanTypeAttribute = /* @__PURE__ */ ((SpanTypeAttribute2) => {
  SpanTypeAttribute2["LLM"] = "llm";
  SpanTypeAttribute2["SCORE"] = "score";
  SpanTypeAttribute2["FUNCTION"] = "function";
  SpanTypeAttribute2["EVAL"] = "eval";
  SpanTypeAttribute2["TASK"] = "task";
  SpanTypeAttribute2["TOOL"] = "tool";
  return SpanTypeAttribute2;
})(SpanTypeAttribute || {});

// typespecs/api_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi4 } from "@asteasolutions/zod-to-openapi";
import { z as z10 } from "zod";

// typespecs/app_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi3 } from "@asteasolutions/zod-to-openapi";
import { z as z9 } from "zod";

// typespecs/common_types.ts
import { z as z3 } from "zod";
import { extendZodWithOpenApi } from "@asteasolutions/zod-to-openapi";
extendZodWithOpenApi(z3);
var literalSchema = z3.union([
  z3.string(),
  z3.number(),
  z3.boolean(),
  z3.null()
]);
var jsonSchema = z3.lazy(
  () => z3.union([literalSchema, z3.array(jsonSchema), z3.record(jsonSchema)])
);
var datetimeStringSchema = z3.string().transform((x, ctx) => {
  const d = new Date(x);
  if (isNaN(d.getTime())) {
    ctx.addIssue({
      code: z3.ZodIssueCode.invalid_string,
      validation: "datetime",
      message: "Invalid datetime"
    });
    return z3.NEVER;
  }
  return d.toISOString();
}).openapi({ format: "date-time" });
var objectTypes = z3.enum([
  "project",
  "experiment",
  "dataset",
  "prompt",
  "prompt_session",
  "role",
  "group",
  "acl",
  "user",
  "project_score",
  "project_tag",
  "function",
  "view",
  "organization"
]);
var objectTypesWithEvent = z3.enum([
  "project",
  "experiment",
  "dataset",
  "prompt",
  "function",
  "prompt_session"
]);
function getEventObjectType(objectType) {
  return objectType === "project" ? "project_logs" : objectType;
}
function getEventObjectDescription(objectType) {
  return getEventObjectType(objectType).replace("_", " ");
}
function getObjectArticle(objectType) {
  return ["acl", "experiment"].includes(objectType) ? "an" : "a";
}

// typespecs/custom_types.ts
import { extendZodWithOpenApi as extendZodWithOpenApi2 } from "@asteasolutions/zod-to-openapi";
import { z as z4 } from "zod";
extendZodWithOpenApi2(z4);
var modeSchema = z4.enum(["default", "stainless"]);
var _a;
var mode = modeSchema.parse(
  typeof process === "undefined" ? "default" : ((_a = process == null ? void 0 : process.env) == null ? void 0 : _a.BRAINTRUST_TYPESPECS_MODE) || "default"
);
var modeToTypes = {
  default: {
    any: z4.any(),
    literalTrue: z4.literal(true),
    literalFalse: z4.literal(false)
  },
  stainless: {
    // Stainless requires schemas which are completely permissive to be
    // tagged.
    any: z4.any().openapi({ ["x-stainless-any"]: true }),
    // Stainless does not support boolean literals in all SDKs.
    literalTrue: z4.boolean(),
    literalFalse: z4.boolean()
  }
};
var customTypes = modeToTypes[mode];

// typespecs/prompt.ts
import { z as z7 } from "zod";

// typespecs/openai/messages.ts
import { z as z5 } from "zod";
var messageRoleSchema = z5.enum([
  "system",
  "user",
  "assistant",
  "function",
  "tool",
  "model"
]);
var chatCompletionSystemMessageParamSchema = z5.object({
  content: z5.string().default(""),
  role: z5.literal("system"),
  name: z5.string().optional()
});
var chatCompletionContentPartTextSchema = z5.object({
  text: z5.string().default(""),
  type: z5.literal("text")
});
var imageURLSchema = z5.object({
  url: z5.string(),
  detail: z5.union([z5.literal("auto"), z5.literal("low"), z5.literal("high")]).optional()
});
var chatCompletionContentPartImageSchema = z5.object({
  image_url: imageURLSchema,
  type: z5.literal("image_url")
});
var chatCompletionContentPartSchema = z5.union([
  chatCompletionContentPartTextSchema,
  chatCompletionContentPartImageSchema
]);
var chatCompletionContentSchema = z5.union([
  z5.string().default(""),
  z5.array(chatCompletionContentPartSchema)
]);
var chatCompletionUserMessageParamSchema = z5.object({
  content: chatCompletionContentSchema,
  role: z5.literal("user"),
  name: z5.string().optional()
});
var functionCallSchema = z5.object({
  arguments: z5.string(),
  name: z5.string()
});
var functionSchema = z5.object({
  arguments: z5.string(),
  name: z5.string()
});
var chatCompletionToolMessageParamSchema = z5.object({
  content: z5.string().default(""),
  role: z5.literal("tool"),
  tool_call_id: z5.string().default("")
});
var chatCompletionFunctionMessageParamSchema = z5.object({
  content: z5.string().default(""),
  name: z5.string(),
  role: z5.literal("function")
});
var chatCompletionMessageToolCallSchema = z5.object({
  id: z5.string(),
  function: functionSchema,
  type: z5.literal("function")
});
var chatCompletionAssistantMessageParamSchema = z5.object({
  role: z5.literal("assistant"),
  content: z5.string().nullish(),
  function_call: functionCallSchema.optional(),
  name: z5.string().optional(),
  tool_calls: z5.array(chatCompletionMessageToolCallSchema).optional()
});
var chatCompletionFallbackMessageParamSchema = z5.object({
  role: messageRoleSchema.exclude([
    "system",
    "user",
    "assistant",
    "tool",
    "function"
  ]),
  content: z5.string().nullish()
});
var chatCompletionOpenAIMessageParamSchema = z5.union([
  chatCompletionSystemMessageParamSchema,
  chatCompletionUserMessageParamSchema,
  chatCompletionAssistantMessageParamSchema,
  chatCompletionToolMessageParamSchema,
  chatCompletionFunctionMessageParamSchema
]);
var chatCompletionMessageParamSchema = z5.union([
  chatCompletionOpenAIMessageParamSchema,
  chatCompletionFallbackMessageParamSchema
]);

// typespecs/openai/tools.ts
import { z as z6 } from "zod";
var functionParametersSchema = z6.record(z6.unknown());
var functionDefinitionSchema = z6.object({
  name: z6.string(),
  description: z6.string().optional(),
  parameters: functionParametersSchema.optional()
});
var chatCompletionToolSchema = z6.object({
  function: functionDefinitionSchema,
  type: z6.literal("function")
});
var toolsSchema = z6.array(chatCompletionToolSchema);

// typespecs/prompt.ts
var promptBlockDataSchema = z7.union([
  z7.object({
    type: z7.literal("completion"),
    content: z7.string()
  }),
  z7.object({
    type: z7.literal("chat"),
    messages: z7.array(chatCompletionMessageParamSchema),
    tools: z7.string().optional()
  })
]);
var braintrustModelParamsSchema = z7.object({
  use_cache: z7.boolean().optional()
});
var BRAINTRUST_PARAMS = Object.keys(braintrustModelParamsSchema.shape);
var openAIModelParamsSchema = z7.object({
  temperature: z7.number().optional(),
  top_p: z7.number().optional(),
  max_tokens: z7.number().optional(),
  frequency_penalty: z7.number().optional(),
  presence_penalty: z7.number().optional(),
  response_format: z7.object({ type: z7.literal("json_object") }).nullish(),
  tool_choice: z7.union([
    z7.literal("auto"),
    z7.literal("none"),
    z7.object({
      type: z7.literal("function"),
      function: z7.object({ name: z7.string() })
    })
  ]).optional(),
  function_call: z7.union([
    z7.literal("auto"),
    z7.literal("none"),
    z7.object({
      name: z7.string()
    })
  ]).optional(),
  n: z7.number().optional(),
  stop: z7.array(z7.string()).optional()
});
var anthropicModelParamsSchema = z7.object({
  max_tokens: z7.number(),
  temperature: z7.number(),
  top_p: z7.number().optional(),
  top_k: z7.number().optional(),
  stop_sequences: z7.array(z7.string()).optional(),
  max_tokens_to_sample: z7.number().optional().describe("This is a legacy parameter that should not be used.")
});
var googleModelParamsSchema = z7.object({
  temperature: z7.number().optional(),
  maxOutputTokens: z7.number().optional(),
  topP: z7.number().optional(),
  topK: z7.number().optional()
});
var windowAIModelParamsSchema = z7.object({
  temperature: z7.number().optional(),
  topK: z7.number().optional()
});
var jsCompletionParamsSchema = z7.object({});
var modelParamsSchema = z7.union([
  braintrustModelParamsSchema.merge(openAIModelParamsSchema).passthrough(),
  braintrustModelParamsSchema.merge(anthropicModelParamsSchema).passthrough(),
  braintrustModelParamsSchema.merge(googleModelParamsSchema).passthrough(),
  braintrustModelParamsSchema.merge(windowAIModelParamsSchema).passthrough(),
  braintrustModelParamsSchema.merge(jsCompletionParamsSchema).passthrough()
]);
var anyModelParamsSchema = openAIModelParamsSchema.merge(anthropicModelParamsSchema).merge(googleModelParamsSchema).merge(braintrustModelParamsSchema);
var promptOptionsSchema = z7.object({
  model: z7.string().optional(),
  params: modelParamsSchema.optional(),
  position: z7.string().optional()
});
var promptDataSchema = z7.object({
  prompt: promptBlockDataSchema.nullish(),
  options: promptOptionsSchema.nullish(),
  origin: z7.object({
    prompt_id: z7.string().optional(),
    project_id: z7.string().optional(),
    prompt_version: z7.string().optional()
  }).nullish()
}).openapi("PromptData");

// typespecs/view.ts
import { z as z8 } from "zod";
var viewTypeEnum = z8.enum([
  "projects",
  "logs",
  "experiments",
  "datasets",
  "prompts",
  "playgrounds",
  "experiment",
  "dataset"
]).describe("Type of table that the view corresponds to.");
var viewDataSearchSchema = z8.object({
  filter: z8.array(customTypes.any).nullish(),
  tag: z8.array(customTypes.any).nullish(),
  match: z8.array(customTypes.any).nullish(),
  sort: z8.array(customTypes.any).nullish()
}).strip().openapi("ViewDataSearch");
var viewDataSchema = z8.object({
  search: viewDataSearchSchema.nullish()
}).strip().openapi("ViewData");
var viewOptionsSchema = z8.object({
  columnVisibility: z8.record(z8.boolean()).nullish(),
  columnOrder: z8.array(z8.string()).nullish(),
  columnSizing: z8.record(z8.number()).nullish()
}).strip().openapi("ViewOptions");

// typespecs/app_types.ts
extendZodWithOpenApi3(z9);
function generateBaseTableSchema(objectName, opts) {
  let nameDescription = `Name of the ${objectName}`;
  if (opts == null ? void 0 : opts.uniqueName) {
    nameDescription += `. Within a project, ${objectName} names are unique`;
  }
  return z9.object({
    id: z9.string().uuid().describe(`Unique identifier for the ${objectName}`),
    project_id: z9.string().uuid().describe(
      `Unique identifier for the project that the ${objectName} belongs under`
    ),
    name: z9.string().describe(nameDescription),
    description: z9.string().nullish().describe(`Textual description of the ${objectName}`),
    created: datetimeStringSchema.nullish().describe(`Date of ${objectName} creation`),
    deleted_at: datetimeStringSchema.nullish().describe(
      `Date of ${objectName} deletion, or null if the ${objectName} is still active`
    ),
    user_id: z9.string().uuid().nullish().describe(`Identifies the user who created the ${objectName}`),
    metadata: z9.record(customTypes.any).nullish().describe(`User-controlled metadata about the ${objectName}`)
  });
}
var userBaseSchema = generateBaseTableSchema("user");
var userSchema = z9.object({
  id: userBaseSchema.shape.id,
  given_name: z9.string().nullish().describe("Given name of the user"),
  family_name: z9.string().nullish().describe("Family name of the user"),
  email: z9.string().nullish().describe("The user's email"),
  avatar_url: z9.string().nullish().describe("URL of the user's Avatar image"),
  created: userBaseSchema.shape.created
}).openapi("User");
var organizationBaseSchema = generateBaseTableSchema("organization");
var organizationSchema = z9.object({
  id: organizationBaseSchema.shape.id,
  name: organizationBaseSchema.shape.name,
  api_url: z9.string().nullish(),
  proxy_url: z9.string().nullish(),
  realtime_url: z9.string().nullish(),
  created: organizationBaseSchema.shape.created
}).openapi("Organization");
var maxOverWindowSchema = z9.object({
  window_size_days: z9.number().int().positive(),
  max_value: z9.number().nonnegative()
}).openapi("MaxOverWindow");
var resourcesSchema = z9.object({
  org_id: organizationSchema.shape.id,
  forbid_toggle_experiment_public_to_private: z9.boolean().nullish(),
  num_private_experiment_row_actions: maxOverWindowSchema.nullish(),
  forbid_insert_datasets: z9.boolean().nullish(),
  forbid_insert_prompt_sessions: z9.boolean().nullish(),
  forbid_access_sql_explorer: z9.boolean().nullish(),
  num_production_log_row_actions: maxOverWindowSchema.nullish(),
  num_dataset_row_actions: maxOverWindowSchema.nullish()
}).openapi("Resources");
var memberSchema = z9.object({
  org_id: organizationSchema.shape.id,
  user_id: userSchema.shape.id
}).openapi("Member");
var orgSecretsBaseSchema = generateBaseTableSchema("org secrets");
var orgSecretsSchema = z9.object({
  id: orgSecretsBaseSchema.shape.id,
  created: orgSecretsBaseSchema.shape.created,
  key_id: z9.string().uuid(),
  org_id: organizationSchema.shape.id,
  name: orgSecretsBaseSchema.shape.name,
  secret: z9.string().nullish(),
  type: z9.string().nullish(),
  metadata: customTypes.any
}).openapi("OrgSecrets");
var apiKeyBaseSchema = generateBaseTableSchema("api key");
var apiKeySchema = z9.object({
  id: apiKeyBaseSchema.shape.id,
  created: apiKeyBaseSchema.shape.created,
  name: apiKeyBaseSchema.shape.name,
  preview_name: z9.string(),
  user_id: userSchema.shape.id.nullish(),
  org_id: organizationSchema.shape.id.nullish()
}).openapi("ApiKey");
var projectSettingsSchema = z9.object({
  comparison_key: z9.string().nullish().describe("The key used to join two experiments (defaults to `input`).")
});
var projectBaseSchema = generateBaseTableSchema("project");
var projectSchema = z9.object({
  id: projectBaseSchema.shape.id,
  org_id: z9.string().uuid().describe(
    "Unique id for the organization that the project belongs under"
  ),
  name: projectBaseSchema.shape.name,
  created: projectBaseSchema.shape.created,
  deleted_at: projectBaseSchema.shape.deleted_at,
  user_id: projectBaseSchema.shape.user_id,
  settings: projectSettingsSchema.nullish()
}).openapi("Project");
var datasetBaseSchema = generateBaseTableSchema("dataset", {
  uniqueName: true
});
var datasetSchema = z9.object({
  id: datasetBaseSchema.shape.id,
  project_id: datasetBaseSchema.shape.project_id.nullish(),
  name: datasetBaseSchema.shape.name,
  description: datasetBaseSchema.shape.description,
  created: datasetBaseSchema.shape.created,
  deleted_at: datasetBaseSchema.shape.deleted_at,
  user_id: datasetBaseSchema.shape.user_id,
  metadata: datasetBaseSchema.shape.metadata
}).openapi("Dataset");
var validRuntimesEnum = z9.enum(["node"]);
var runtimeContextSchema = z9.object({
  runtime: validRuntimesEnum,
  version: z9.string()
});
var promptBaseSchema = generateBaseTableSchema("prompt");
var promptSchemaObject = z9.object({
  id: promptBaseSchema.shape.id,
  // This has to be copy/pasted because zod blows up when there are circular dependencies
  _xact_id: z9.string().describe(
    `The transaction id of an event is unique to the network operation that processed the event insertion. Transaction ids are monotonically increasing over time and can be used to retrieve a versioned snapshot of the prompt (see the \`version\` parameter)`
  ),
  project_id: promptBaseSchema.shape.project_id,
  log_id: z9.literal("p").describe("A literal 'p' which identifies the object as a project prompt"),
  org_id: organizationSchema.shape.id,
  name: promptBaseSchema.shape.name,
  slug: z9.string().describe("Unique identifier for the prompt"),
  description: promptBaseSchema.shape.description,
  created: promptBaseSchema.shape.created,
  prompt_data: promptDataSchema.nullish().describe("The prompt, model, and its parameters"),
  tags: z9.array(z9.string()).nullish().describe("A list of tags for the prompt"),
  metadata: promptBaseSchema.shape.metadata
});
var promptSchema = promptSchemaObject.openapi("Prompt");
var codeBundleSchema = z9.object({
  runtime_context: z9.object({
    runtime: validRuntimesEnum,
    version: z9.string()
  }),
  // This should be a union, once we support code living in different places
  // Other options should be:
  //  - a "handler" function that has some signature [does AWS lambda assume it's always called "handler"?]
  location: z9.object({
    type: z9.literal("experiment"),
    eval_name: z9.string(),
    position: z9.union([z9.literal("task"), z9.object({ score: z9.number() })])
  }),
  bundle_id: z9.string()
});
var functionDataSchema = z9.union([
  z9.object({
    type: z9.literal("prompt")
    // For backwards compatibility reasons, this is hoisted out and stored
    // in the outer object
  }),
  z9.object({
    type: z9.literal("code"),
    data: codeBundleSchema
  }),
  z9.object({
    type: z9.literal("global"),
    name: z9.string()
  })
]);
var functionSchema2 = promptSchemaObject.merge(
  z9.object({
    function_data: functionDataSchema
  })
).openapi("Function");
var repoInfoSchema = z9.object({
  commit: z9.string().nullish().describe("SHA of most recent commit"),
  branch: z9.string().nullish().describe("Name of the branch the most recent commit belongs to"),
  tag: z9.string().nullish().describe("Name of the tag on the most recent commit"),
  dirty: z9.boolean().nullish().describe(
    "Whether or not the repo had uncommitted changes when snapshotted"
  ),
  author_name: z9.string().nullish().describe("Name of the author of the most recent commit"),
  author_email: z9.string().nullish().describe("Email of the author of the most recent commit"),
  commit_message: z9.string().nullish().describe("Most recent commit message"),
  commit_time: z9.string().nullish().describe("Time of the most recent commit"),
  git_diff: z9.string().nullish().describe(
    "If the repo was dirty when run, this includes the diff between the current state of the repo and the most recent commit."
  )
}).describe(
  "Metadata about the state of the repo when the experiment was created"
).openapi("RepoInfo");
var experimentBaseSchema = generateBaseTableSchema("experiment", {
  uniqueName: true
});
var experimentSchema = z9.object({
  id: experimentBaseSchema.shape.id,
  project_id: experimentBaseSchema.shape.project_id,
  name: experimentBaseSchema.shape.name,
  description: experimentBaseSchema.shape.description,
  created: experimentBaseSchema.shape.created,
  repo_info: repoInfoSchema.nullish(),
  commit: z9.string().nullish().describe("Commit, taken directly from `repo_info.commit`"),
  base_exp_id: z9.string().uuid().nullish().describe(
    "Id of default base experiment to compare against when viewing this experiment"
  ),
  deleted_at: experimentBaseSchema.shape.deleted_at,
  dataset_id: z9.string().uuid().nullish().describe(
    "Identifier of the linked dataset, or null if the experiment is not linked to a dataset"
  ),
  dataset_version: z9.string().nullish().describe(
    "Version number of the linked dataset the experiment was run against. This can be used to reproduce the experiment after the dataset has been modified."
  ),
  public: z9.boolean().describe(
    "Whether or not the experiment is public. Public experiments can be viewed by anybody inside or outside the organization"
  ),
  user_id: experimentBaseSchema.shape.user_id,
  metadata: experimentBaseSchema.shape.metadata
}).openapi("Experiment");
var promptSessionBaseSchema = generateBaseTableSchema("promptSession", {
  uniqueName: true
});
var promptSessionSchema = z9.object({
  id: promptSessionBaseSchema.shape.id,
  name: promptSessionBaseSchema.shape.name,
  description: promptSessionBaseSchema.shape.description,
  created: promptSessionBaseSchema.shape.created,
  deleted_at: promptSessionBaseSchema.shape.deleted_at,
  user_id: promptSessionBaseSchema.shape.user_id,
  project_id: promptSessionBaseSchema.shape.project_id,
  org_id: organizationSchema.shape.id.nullish().describe(
    "This field is deprecated and will be removed in a future revision"
  )
}).openapi("PromptSession");
var permissionEnum = z9.enum([
  "create",
  "read",
  "update",
  "delete",
  "create_acls",
  "read_acls",
  "update_acls",
  "delete_acls"
]).describe(
  [
    "Each permission permits a certain type of operation on an object in the system",
    "Permissions can be assigned to to objects on an individual basis, or grouped into roles"
  ].join("\n\n")
);
var aclObjectTypeEnum = z9.enum([
  "organization",
  "project",
  "experiment",
  "dataset",
  "prompt",
  "prompt_session",
  "group",
  "role",
  "org_member",
  "project_log",
  "org_project"
]).describe("The object type that the ACL applies to");
var roleBaseSchema = generateBaseTableSchema("role");
var roleSchema = z9.object({
  id: roleBaseSchema.shape.id,
  org_id: z9.string().uuid().nullish().describe(
    [
      "Unique id for the organization that the role belongs under",
      "A null org_id indicates a system role, which may be assigned to anybody and inherited by any other role, but cannot be edited.",
      "It is forbidden to change the org after creating a role"
    ].join("\n\n")
  ),
  user_id: roleBaseSchema.shape.user_id,
  created: roleBaseSchema.shape.created,
  name: roleBaseSchema.shape.name,
  description: roleBaseSchema.shape.description,
  deleted_at: roleBaseSchema.shape.deleted_at,
  member_permissions: z9.array(
    z9.object({
      permission: permissionEnum,
      restrict_object_type: aclObjectTypeEnum.nullish()
    })
  ).nullish().describe(
    "(permission, restrict_object_type) tuples which belong to this role"
  ),
  member_roles: z9.array(z9.string().uuid()).nullish().describe(
    [
      "Ids of the roles this role inherits from",
      "An inheriting role has all the permissions contained in its member roles, as well as all of their inherited permissions"
    ].join("\n\n")
  )
}).describe(
  [
    "A role is a collection of permissions which can be granted as part of an ACL",
    "Roles can consist of individual permissions, as well as a set of roles they inherit from"
  ].join("\n\n")
).openapi("Role");
var groupBaseSchema = generateBaseTableSchema("group");
var groupSchema = z9.object({
  id: groupBaseSchema.shape.id,
  org_id: z9.string().uuid().describe(
    [
      "Unique id for the organization that the group belongs under",
      "It is forbidden to change the org after creating a group"
    ].join("\n\n")
  ),
  user_id: groupBaseSchema.shape.user_id,
  created: groupBaseSchema.shape.created,
  name: groupBaseSchema.shape.name,
  description: groupBaseSchema.shape.description,
  deleted_at: groupBaseSchema.shape.deleted_at,
  member_users: z9.array(z9.string().uuid()).nullish().describe("Ids of users which belong to this group"),
  member_groups: z9.array(z9.string().uuid()).nullish().describe(
    [
      "Ids of the groups this group inherits from",
      "An inheriting group has all the users contained in its member groups, as well as all of their inherited users"
    ].join("\n\n")
  )
}).describe(
  [
    "A group is a collection of users which can be assigned an ACL",
    "Groups can consist of individual users, as well as a set of groups they inherit from"
  ].join("\n\n")
).openapi("Group");
var projectScoreTypeEnum = z9.enum(["slider", "categorical", "weighted", "minimum"]).describe("The type of the configured score");
var projectScoreCategory = z9.object({
  name: z9.string().describe("Name of the category"),
  value: z9.number().describe(
    "Numerical value of the category. Must be between 0 and 1, inclusive"
  )
}).describe("For categorical-type project scores, defines a single category").openapi("ProjectScoreCategory");
var projectScoreBaseSchema = generateBaseTableSchema("project score");
var projectScoreSchema = z9.object({
  id: projectScoreBaseSchema.shape.id,
  project_id: projectScoreBaseSchema.shape.project_id,
  user_id: projectScoreBaseSchema.shape.user_id.unwrap().unwrap(),
  created: projectScoreBaseSchema.shape.created,
  name: projectScoreBaseSchema.shape.name,
  description: projectScoreBaseSchema.shape.description,
  score_type: projectScoreTypeEnum,
  categories: z9.union([
    projectScoreCategory.array().describe(
      "For categorical-type project scores, the list of all categories"
    ),
    z9.record(z9.number()).describe(
      "For weighted-type project scores, the weights of each score"
    ),
    z9.array(z9.string()).describe(
      "For minimum-type project scores, the list of included scores"
    )
  ]).nullish(),
  config: z9.object({
    multi_select: z9.boolean().nullish(),
    destination: z9.literal("expected").nullish()
  }).nullish(),
  position: z9.string().nullish().describe(
    "An optional LexoRank-based string that sets the sort position for the score in the UI"
  )
}).describe(
  "A project score is a user-configured score, which can be manually-labeled through the UI"
).openapi("ProjectScore");
var projectTagBaseSchema = generateBaseTableSchema("project tag");
var projectTagSchema = z9.object({
  id: projectTagBaseSchema.shape.id,
  project_id: projectTagBaseSchema.shape.project_id,
  user_id: projectTagBaseSchema.shape.user_id.unwrap().unwrap(),
  created: projectTagBaseSchema.shape.created,
  name: projectTagBaseSchema.shape.name,
  description: projectTagBaseSchema.shape.description,
  color: z9.string().nullish().describe("Color of the tag for the UI")
}).describe(
  "A project tag is a user-configured tag for tracking and filtering your experiments, logs, and other data"
).openapi("ProjectTag");
var viewBaseSchema = generateBaseTableSchema("view");
var viewSchema = z9.object({
  id: viewBaseSchema.shape.id,
  object_type: aclObjectTypeEnum,
  object_id: z9.string().uuid().describe("The id of the object the view applies to"),
  view_type: viewTypeEnum,
  name: viewBaseSchema.shape.name,
  created: viewBaseSchema.shape.created,
  view_data: viewDataSchema.nullish().describe("The view definition"),
  options: viewOptionsSchema.nullish().describe("Options for the view in the app"),
  user_id: viewBaseSchema.shape.user_id,
  deleted_at: roleBaseSchema.shape.deleted_at
}).openapi("View");
var aclBaseSchema = generateBaseTableSchema("acl");
var aclSchema = z9.object({
  id: aclBaseSchema.shape.id,
  object_type: aclObjectTypeEnum,
  object_id: z9.string().uuid().describe("The id of the object the ACL applies to"),
  user_id: z9.string().uuid().nullish().describe(
    "Id of the user the ACL applies to. Exactly one of `user_id` and `group_id` will be provided"
  ),
  group_id: z9.string().uuid().nullish().describe(
    "Id of the group the ACL applies to. Exactly one of `user_id` and `group_id` will be provided"
  ),
  permission: permissionEnum.nullish().describe(
    "Permission the ACL grants. Exactly one of `permission` and `role_id` will be provided"
  ),
  restrict_object_type: aclObjectTypeEnum.nullish().describe(
    "When setting a permission directly, optionally restricts the permission grant to just the specified object type. Cannot be set alongside a `role_id`."
  ),
  role_id: z9.string().uuid().nullish().describe(
    "Id of the role the ACL grants. Exactly one of `permission` and `role_id` will be provided"
  ),
  _object_org_id: z9.string().uuid().describe("The organization the ACL's referred object belongs to"),
  created: aclBaseSchema.shape.created
}).describe(
  [
    "An ACL grants a certain permission or role to a certain user or group on an object.",
    "ACLs are inherited across the object hierarchy. So for example, if a user has read permissions on a project, they will also have read permissions on any experiment, dataset, etc. created within that project.",
    "To restrict a grant to a particular sub-object, you may specify `restrict_object_type` in the ACL, as part of a direct permission grant or as part of a role."
  ].join("\n\n")
).openapi("Acl");
var appLimitSchema = z9.number().int().nonnegative().describe("Limit the number of objects to return");
function generateBaseTableOpSchema(objectName) {
  return z9.object({
    org_name: z9.string().nullish().describe(
      `For nearly all users, this parameter should be unnecessary. But in the rare case that your API key belongs to multiple organizations, you may specify the name of the organization the ${objectName} belongs in.`
    )
  });
}
var startingAfterSchema = z9.string().uuid().describe(
  [
    "Pagination cursor id.",
    "For example, if the final item in the last page you fetched had an id of `foo`, pass `starting_after=foo` to fetch the next page. Note: you may only pass one of `starting_after` and `ending_before`"
  ].join("\n\n")
).openapi("StartingAfter");
var endingBeforeSchema = z9.string().uuid().describe(
  [
    "Pagination cursor id.",
    "For example, if the initial item in the last page you fetched had an id of `foo`, pass `ending_before=foo` to fetch the previous page. Note: you may only pass one of `starting_after` and `ending_before`"
  ].join("\n\n")
).openapi("EndingBefore");
var createProjectBaseSchema = generateBaseTableOpSchema("project");
var createProjectSchema = z9.object({
  name: projectSchema.shape.name,
  org_name: createProjectBaseSchema.shape.org_name
}).openapi("CreateProject");
var patchProjectSchema = z9.object({
  name: projectSchema.shape.name.nullish(),
  settings: projectSchema.shape.settings.describe(
    "Project settings. Patch operations replace all settings, so make sure you include all settings you want to keep."
  ).nullish()
}).openapi("PatchProject");
var createExperimentSchema = z9.object({
  project_id: experimentSchema.shape.project_id,
  name: experimentSchema.shape.name.nullish(),
  description: experimentSchema.shape.description,
  repo_info: experimentSchema.shape.repo_info,
  base_exp_id: experimentSchema.shape.base_exp_id,
  dataset_id: experimentSchema.shape.dataset_id,
  dataset_version: experimentSchema.shape.dataset_version,
  public: experimentSchema.shape.public.nullish(),
  metadata: experimentSchema.shape.metadata,
  ensure_new: z9.boolean().nullish().describe(
    "Normally, creating an experiment with the same name as an existing experiment will return the existing one un-modified. But if `ensure_new` is true, registration will generate a new experiment with a unique name in case of a conflict."
  )
}).openapi("CreateExperiment");
var patchExperimentSchema = createExperimentSchema.omit({ project_id: true, ensure_new: true }).openapi("PatchExperiment");
var createDatasetSchema = z9.object({
  project_id: datasetSchema.shape.project_id,
  name: datasetSchema.shape.name,
  description: datasetSchema.shape.description
}).openapi("CreateDataset");
var patchDatasetSchema = z9.object({
  name: datasetSchema.shape.name.nullish(),
  description: datasetSchema.shape.description,
  metadata: datasetSchema.shape.metadata
}).openapi("PatchDataset");
var createPromptSchema = promptSchema.omit({
  id: true,
  _xact_id: true,
  org_id: true,
  log_id: true,
  created: true,
  metadata: true
}).openapi("CreatePrompt");
var createFunctionSchema = functionSchema2.omit({
  id: true,
  _xact_id: true,
  org_id: true,
  log_id: true,
  created: true,
  metadata: true
}).openapi("CreateFunction");
var patchPromptSchema = z9.object({
  name: promptSchema.shape.name.nullish(),
  description: promptSchema.shape.description.nullish(),
  prompt_data: promptSchema.shape.prompt_data.nullish(),
  tags: promptSchema.shape.tags.nullish()
}).openapi("PatchPrompt");
var patchFunctionSchema = z9.object({
  name: functionSchema2.shape.name.nullish(),
  description: functionSchema2.shape.description.nullish(),
  prompt_data: functionSchema2.shape.prompt_data.nullish(),
  function_data: functionSchema2.shape.function_data.nullish(),
  tags: functionSchema2.shape.tags.nullish()
}).openapi("PatchFunction");
var createRoleBaseSchema = generateBaseTableOpSchema("role");
var createRoleSchema = z9.object({
  name: roleSchema.shape.name,
  description: roleSchema.shape.description,
  member_permissions: roleSchema.shape.member_permissions,
  member_roles: roleSchema.shape.member_roles,
  org_name: createRoleBaseSchema.shape.org_name
}).openapi("CreateRole");
var patchRoleSchema = createRoleSchema.omit({
  name: true,
  org_name: true,
  member_permissions: true,
  member_roles: true
}).merge(
  z9.object({
    name: createRoleSchema.shape.name.nullish(),
    add_member_permissions: roleSchema.shape.member_permissions.nullish().describe("A list of permissions to add to the role"),
    remove_member_permissions: roleSchema.shape.member_permissions.nullish().describe("A list of permissions to remove from the role"),
    add_member_roles: roleSchema.shape.member_roles.nullish().describe(
      "A list of role IDs to add to the role's inheriting-from set"
    ),
    remove_member_roles: roleSchema.shape.member_roles.nullish().describe(
      "A list of role IDs to remove from the role's inheriting-from set"
    )
  })
).openapi("PatchRole");
var createGroupBaseSchema = generateBaseTableOpSchema("group");
var createGroupSchema = z9.object({
  name: groupSchema.shape.name,
  description: groupSchema.shape.description,
  member_users: groupSchema.shape.member_users,
  member_groups: groupSchema.shape.member_groups,
  org_name: createGroupBaseSchema.shape.org_name
}).openapi("CreateGroup");
var patchGroupSchema = createGroupSchema.omit({ name: true, org_name: true, member_users: true, member_groups: true }).merge(
  z9.object({
    name: createGroupSchema.shape.name.nullish(),
    add_member_users: groupSchema.shape.member_users.nullish().describe("A list of user IDs to add to the group"),
    remove_member_users: groupSchema.shape.member_users.nullish().describe("A list of user IDs to remove from the group"),
    add_member_groups: groupSchema.shape.member_groups.nullish().describe(
      "A list of group IDs to add to the group's inheriting-from set"
    ),
    remove_member_groups: groupSchema.shape.member_groups.nullish().describe(
      "A list of group IDs to remove from the group's inheriting-from set"
    )
  })
).openapi("PatchGroup");
var createAclSchema = aclSchema.omit({
  id: true,
  created: true,
  _object_org_id: true
}).openapi("CreateAcl");
var createProjectScoreSchema = z9.object({
  project_id: projectScoreSchema.shape.project_id,
  name: projectScoreSchema.shape.name,
  description: projectScoreSchema.shape.description,
  score_type: projectScoreSchema.shape.score_type,
  categories: projectScoreSchema.shape.categories
}).openapi("CreateProjectScore");
var patchProjectScoreSchema = z9.object({
  name: projectScoreSchema.shape.name.nullish(),
  description: projectScoreSchema.shape.description,
  score_type: projectScoreSchema.shape.score_type.nullish(),
  categories: projectScoreSchema.shape.categories
}).openapi("PatchProjectScore");
var createProjectTagSchema = z9.object({
  project_id: projectTagSchema.shape.project_id,
  name: projectTagSchema.shape.name,
  description: projectTagSchema.shape.description,
  color: projectTagSchema.shape.color
}).openapi("CreateProjectTag");
var patchProjectTagSchema = z9.object({
  name: projectTagSchema.shape.name.nullish(),
  description: projectTagSchema.shape.description,
  color: projectTagSchema.shape.color
}).openapi("PatchProjectTag");
var createViewSchema = viewSchema.omit({
  id: true,
  created: true
}).openapi("CreateView");
var patchViewSchema = z9.object({
  object_type: viewSchema.shape.object_type,
  object_id: viewSchema.shape.object_id,
  view_type: viewSchema.shape.view_type.nullish(),
  name: viewSchema.shape.name.nullish(),
  view_data: viewSchema.shape.view_data,
  options: viewSchema.shape.options,
  user_id: viewSchema.shape.user_id
}).openapi("PatchView");
var deleteViewSchema = z9.object({
  object_type: viewSchema.shape.object_type,
  object_id: viewSchema.shape.object_id
}).openapi("DeleteView");
var patchOrganizationSchema = z9.object({
  name: organizationSchema.shape.name.nullish(),
  api_url: organizationSchema.shape.api_url.nullish(),
  proxy_url: organizationSchema.shape.proxy_url.nullish(),
  realtime_url: organizationSchema.shape.realtime_url.nullish()
}).openapi("PatchOrganization");

// typespecs/api_types.ts
extendZodWithOpenApi4(z10);
var auditSourcesSchema = z10.enum(VALID_SOURCES);
function generateBaseEventOpSchema(objectType) {
  const eventDescription = getEventObjectDescription(objectType);
  return z10.object({
    id: z10.string().describe(
      `A unique identifier for the ${eventDescription} event. If you don't provide one, BrainTrust will generate one for you`
    ),
    [TRANSACTION_ID_FIELD]: z10.string().describe(
      `The transaction id of an event is unique to the network operation that processed the event insertion. Transaction ids are monotonically increasing over time and can be used to retrieve a versioned snapshot of the ${eventDescription} (see the \`version\` parameter)`
    ),
    created: datetimeStringSchema.describe(
      `The timestamp the ${eventDescription} event was created`
    ),
    input: customTypes.any,
    output: customTypes.any,
    expected: customTypes.any,
    tags: z10.array(z10.string()).nullish().describe("A list of tags to log"),
    scores: z10.record(z10.number().min(0).max(1).nullish()).nullish(),
    metadata: z10.record(customTypes.any).nullish().describe(
      "A dictionary with additional data about the test example, model outputs, or just about anything else that's relevant, that you can use to help find and analyze examples later. For example, you could log the `prompt`, example's `id`, or anything else that would be useful to slice/dice later. The values in `metadata` can be any JSON-serializable type, but its keys must be strings"
    ),
    metrics: z10.object({
      start: z10.number().nullish().describe(
        `A unix timestamp recording when the section of code which produced the ${eventDescription} event started`
      ),
      end: z10.number().nullish().describe(
        `A unix timestamp recording when the section of code which produced the ${eventDescription} event finished`
      ),
      prompt_tokens: z10.number().int().nullish().describe(
        `The number of tokens in the prompt used to generate the ${eventDescription} event (only set if this is an LLM span)`
      ),
      completion_tokens: z10.number().int().nullish().describe(
        `The number of tokens in the completion generated by the model (only set if this is an LLM span)`
      ),
      tokens: z10.number().int().nullish().describe(
        `The total number of tokens in the input and output of the ${eventDescription} event.`
      )
    }).catchall(customTypes.any).nullish().describe(
      `Metrics are numerical measurements tracking the execution of the code that produced the ${eventDescription} event. Use "start" and "end" to track the time span over which the ${eventDescription} event was produced`
    ),
    context: z10.object({
      caller_functionname: z10.string().nullish().describe(
        `The function in code which created the ${eventDescription} event`
      ),
      caller_filename: z10.string().nullish().describe(
        `Name of the file in code where the ${eventDescription} event was created`
      ),
      caller_lineno: z10.number().int().nullish().describe(
        `Line of code where the ${eventDescription} event was created`
      )
    }).catchall(customTypes.any).nullish().describe(
      `Context is additional information about the code that produced the ${eventDescription} event. It is essentially the textual counterpart to \`metrics\`. Use the \`caller_*\` attributes to track the location in code which produced the ${eventDescription} event`
    ),
    span_id: z10.string().uuid().describe(
      `A unique identifier used to link different ${eventDescription} events together as part of a full trace. See the [tracing guide](https://www.braintrust.dev/docs/guides/tracing) for full details on tracing`
    ),
    span_parents: z10.string().array().nullish().describe(
      `An array of the parent \`span_ids\` of this ${eventDescription} event. This should be empty for the root span of a trace, and should most often contain just one parent element for subspans`
    ),
    root_span_id: z10.string().uuid().describe(
      `The \`span_id\` of the root of the trace this ${eventDescription} event belongs to`
    ),
    span_attributes: z10.object({
      name: z10.string().nullish().describe("Name of the span, for display purposes only"),
      type: z10.enum(spanTypeAttributeValues).nullish().describe("Type of the span, for display purposes only")
    }).catchall(customTypes.any).nullish().describe(
      "Human-identifying attributes of the span, such as name, type, etc."
    ),
    [OBJECT_DELETE_FIELD]: z10.boolean().nullish().describe(
      `Pass \`${OBJECT_DELETE_FIELD}=true\` to mark the ${eventDescription} event deleted. Deleted events will not show up in subsequent fetches for this ${eventDescription}`
    )
  });
}
function generateBaseEventFeedbackSchema(objectType) {
  const eventObjectType = getEventObjectType(objectType);
  const eventDescription = getEventObjectDescription(objectType);
  return z10.object({
    id: z10.string().describe(
      `The id of the ${eventDescription} event to log feedback for. This is the row \`id\` returned by \`POST /v1/${eventObjectType}/{${objectType}_id}/insert\``
    ),
    scores: z10.record(z10.number().min(0).max(1).nullish()).nullish().describe(
      `A dictionary of numeric values (between 0 and 1) to log. These scores will be merged into the existing scores for the ${eventDescription} event`
    ),
    expected: customTypes.any.describe(
      "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not"
    ),
    tags: z10.array(z10.string()).nullish().describe("A list of tags to log"),
    comment: z10.string().nullish().describe(
      `An optional comment string to log about the ${eventDescription} event`
    ),
    metadata: z10.record(customTypes.any).nullish().describe(
      "A dictionary with additional data about the feedback. If you have a `user_id`, you can log it here and access it in the Braintrust UI."
    ),
    source: auditSourcesSchema.nullish().describe(
      'The source of the feedback. Must be one of "external" (default), "app", or "api"'
    )
  });
}
var fetchLimitSchema = z10.number().int().nonnegative().describe(
  [
    "limit the number of traces fetched",
    `Fetch queries may be paginated if the total result size is expected to be large (e.g. project_logs which accumulate over a long time). Note that fetch queries only support pagination in descending time order (from latest to earliest \`${TRANSACTION_ID_FIELD}\`. Furthermore, later pages may return rows which showed up in earlier pages, except with an earlier \`${TRANSACTION_ID_FIELD}\`. This happens because pagination occurs over the whole version history of the event log. You will most likely want to exclude any such duplicate, outdated rows (by \`id\`) from your combined result set.`,
    `The \`limit\` parameter controls the number of full traces to return. So you may end up with more individual rows than the specified limit if you are fetching events containing traces.`
  ].join("\n\n")
);
var fetchPaginationCursorDescription = [
  "DEPRECATION NOTICE: The manually-constructed pagination cursor is deprecated in favor of the explicit 'cursor' returned by object fetch requests. Please prefer the 'cursor' argument going forwards.",
  "Together, `max_xact_id` and `max_root_span_id` form a pagination cursor",
  `Since a paginated fetch query returns results in order from latest to earliest, the cursor for the next page can be found as the row with the minimum (earliest) value of the tuple \`(${TRANSACTION_ID_FIELD}, root_span_id)\`. See the documentation of \`limit\` for an overview of paginating fetch queries.`
].join("\n\n");
var maxXactIdSchema = z10.string().describe(fetchPaginationCursorDescription);
var maxRootSpanIdSchema = z10.string().describe(fetchPaginationCursorDescription);
var fetchPaginationCursorSchema = z10.string().describe(
  [
    "An opaque string to be used as a cursor for the next page of results, in order from latest to earliest.",
    "The string can be obtained directly from the `cursor` property of the previous fetch query"
  ].join("\n\n")
);
var versionSchema = z10.string().describe(
  [
    "Retrieve a snapshot of events from a past time",
    "The version id is essentially a filter on the latest event transaction id. You can use the `max_xact_id` returned by a past fetch as the version to reproduce that exact fetch."
  ].join("\n\n")
);
var pathTypeFilterSchema = z10.object({
  type: z10.literal("path_lookup").describe("Denotes the type of filter as a path-lookup filter"),
  path: z10.string().array().describe(
    'List of fields describing the path to the value to be checked against. For instance, if you wish to filter on the value of `c` in `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `path=["input", "a", "b", "c"]`'
  ),
  value: customTypes.any.describe(
    'The value to compare equality-wise against the event value at the specified `path`. The value must be a "primitive", that is, any JSON-serializable object except for objects and arrays. For instance, if you wish to filter on the value of "input.a.b.c" in the object `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `value="hello"`'
  )
}).describe(
  'A path-lookup filter describes an equality comparison against a specific sub-field in the event row. For instance, if you wish to filter on the value of `c` in `{"input": {"a": {"b": {"c": "hello"}}}}`, pass `path=["input", "a", "b", "c"]` and `value="hello"`'
).openapi("PathLookupFilter");
var sqlTypeFilterSchema = z10.object({
  type: z10.literal("sql_filter").describe("Denotes the type of filter as a sql-type filter"),
  expr: z10.string().describe(
    `A SQL expression in [duckDB syntax](https://duckdb.org/docs/sql/expressions/overview). For instance, if you wish to fuzzy-match the value of \`c\` in \`{"input": {"a": {"b": {"c": "hello"}}}}\`, pass \`expr="input->'a'->'b'->>'c' LIKE '%el%'"\`.`
  )
}).describe(
  `A sql-type filter describes a general filter over an individual row in [duckDB syntax](https://duckdb.org/docs/sql/expressions/overview). For instance, if you wish to fuzzy-match the value of \`c\` in \`{"input": {"a": {"b": {"c": "hello"}}}}\`, pass \`expr="input->'a'->'b'->>'c' LIKE '%el%'"\`.`
).openapi("SQLFilter");
var allFetchFiltersSchema = z10.union([pathTypeFilterSchema, sqlTypeFilterSchema]).array().describe(
  "A list of filters on the events to fetch. Filters can either be specialized `path=value` expressions or general SQL expressions in [duckDB syntax](https://duckdb.org/docs/sql/expressions/overview). When possible, prefer path-lookup type filters over general SQL-type filters, as they are likely to activate indices in the DB and run faster"
).openapi("AllFetchEventsFilters");
var fetchFiltersSchema = pathTypeFilterSchema.array().describe(
  "A list of filters on the events to fetch. Currently, only path-lookup type filters are supported, but we may add more in the future"
).openapi("FetchEventsFilters");
var fetchEventsRequestSchema = z10.object({
  limit: fetchLimitSchema.nullish(),
  cursor: fetchPaginationCursorSchema.nullish(),
  max_xact_id: maxXactIdSchema.nullish(),
  max_root_span_id: maxRootSpanIdSchema.nullish(),
  filters: fetchFiltersSchema.nullish(),
  version: versionSchema.nullish()
}).openapi("FetchEventsRequest");
function makeFetchEventsResponseSchema(objectType, eventSchema) {
  const eventName = capitalize(getEventObjectType(objectType), "_").replace(
    "_",
    ""
  );
  return z10.object({
    events: eventSchema.array().describe("A list of fetched events"),
    cursor: z10.string().nullish().describe(
      [
        "Pagination cursor",
        "Pass this string directly as the `cursor` param to your next fetch request to get the next page of results. Not provided if the returned result set is empty."
      ].join("\n\n")
    )
  }).openapi(`Fetch${eventName}EventsResponse`);
}
var experimentEventBaseSchema = generateBaseEventOpSchema("experiment");
var experimentEventSchema = z10.object({
  id: experimentEventBaseSchema.shape.id,
  dataset_record_id: z10.string().nullish().describe(
    "If the experiment is associated to a dataset, this is the event-level dataset id this experiment event is tied to"
  ),
  [TRANSACTION_ID_FIELD]: experimentEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: experimentEventBaseSchema.shape.created,
  project_id: experimentSchema.shape.project_id,
  experiment_id: experimentSchema.shape.id,
  input: experimentEventBaseSchema.shape.input.describe(
    "The arguments that uniquely define a test case (an arbitrary, JSON serializable object). Later on, Braintrust will use the `input` to know whether two test cases are the same between experiments, so they should not contain experiment-specific state. A simple rule of thumb is that if you run the same experiment twice, the `input` should be identical"
  ),
  output: experimentEventBaseSchema.shape.output.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question"
  ),
  expected: experimentEventBaseSchema.shape.expected.describe(
    "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate your experiments while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models"
  ),
  scores: experimentEventBaseSchema.shape.scores.describe(
    "A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare experiments"
  ),
  metadata: experimentEventBaseSchema.shape.metadata,
  tags: experimentEventBaseSchema.shape.tags,
  metrics: experimentEventBaseSchema.shape.metrics,
  context: experimentEventBaseSchema.shape.context,
  span_id: experimentEventBaseSchema.shape.span_id,
  span_parents: experimentEventBaseSchema.shape.span_parents,
  root_span_id: experimentEventBaseSchema.shape.root_span_id,
  span_attributes: experimentEventBaseSchema.shape.span_attributes
}).openapi("ExperimentEvent");
var datasetEventBaseSchema = generateBaseEventOpSchema("dataset");
var datasetEventSchema = z10.object({
  id: datasetEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: datasetEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: datasetEventBaseSchema.shape.created,
  project_id: datasetSchema.shape.project_id,
  dataset_id: datasetSchema.shape.id,
  input: datasetEventBaseSchema.shape.input.describe(
    "The argument that uniquely define an input case (an arbitrary, JSON serializable object)"
  ),
  expected: datasetEventBaseSchema.shape.expected.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object)"
  ),
  metadata: datasetEventBaseSchema.shape.metadata,
  tags: datasetEventBaseSchema.shape.tags,
  span_id: datasetEventBaseSchema.shape.span_id,
  root_span_id: datasetEventBaseSchema.shape.root_span_id
}).openapi("DatasetEvent");
var promptSessionEventBaseSchema = generateBaseEventOpSchema("prompt_session");
var promptSessionEventSchema = z10.object({
  id: promptSessionEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: promptSessionEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: promptSessionEventBaseSchema.shape.created,
  project_id: promptSchema.shape.project_id,
  prompt_session_id: promptSchema.shape.id,
  prompt_session_data: customTypes.any.describe(
    "Data about the prompt session"
  ),
  prompt_data: customTypes.any.describe("Data about the prompt"),
  object_data: customTypes.any.describe("Data about the mapped data"),
  completion: customTypes.any.describe("Data about the completion"),
  tags: promptSessionEventBaseSchema.shape.tags
}).openapi("PromptSessionEvent");
var projectLogsEventBaseSchema = generateBaseEventOpSchema("project");
var projectLogsEventSchema = z10.object({
  id: projectLogsEventBaseSchema.shape.id,
  [TRANSACTION_ID_FIELD]: projectLogsEventBaseSchema.shape[TRANSACTION_ID_FIELD],
  created: projectLogsEventBaseSchema.shape.created,
  org_id: projectSchema.shape.org_id,
  project_id: projectSchema.shape.id,
  log_id: z10.literal("g").describe("A literal 'g' which identifies the log as a project log"),
  input: projectLogsEventBaseSchema.shape.input.describe(
    "The arguments that uniquely define a user input (an arbitrary, JSON serializable object)."
  ),
  output: projectLogsEventBaseSchema.shape.output.describe(
    "The output of your application, including post-processing (an arbitrary, JSON serializable object), that allows you to determine whether the result is correct or not. For example, in an app that generates SQL queries, the `output` should be the _result_ of the SQL query generated by the model, not the query itself, because there may be multiple valid queries that answer a single question."
  ),
  expected: projectLogsEventBaseSchema.shape.expected.describe(
    "The ground truth value (an arbitrary, JSON serializable object) that you'd compare to `output` to determine if your `output` value is correct or not. Braintrust currently does not compare `output` to `expected` for you, since there are so many different ways to do that correctly. Instead, these values are just used to help you navigate while digging into analyses. However, we may later use these values to re-score outputs or fine-tune your models."
  ),
  scores: projectLogsEventBaseSchema.shape.scores.describe(
    "A dictionary of numeric values (between 0 and 1) to log. The scores should give you a variety of signals that help you determine how accurate the outputs are compared to what you expect and diagnose failures. For example, a summarization app might have one score that tells you how accurate the summary is, and another that measures the word similarity between the generated and grouth truth summary. The word similarity score could help you determine whether the summarization was covering similar concepts or not. You can use these scores to help you sort, filter, and compare logs."
  ),
  metadata: projectLogsEventBaseSchema.shape.metadata,
  tags: projectLogsEventBaseSchema.shape.tags,
  metrics: projectLogsEventBaseSchema.shape.metrics,
  context: projectLogsEventBaseSchema.shape.context,
  span_id: projectLogsEventBaseSchema.shape.span_id,
  span_parents: projectLogsEventBaseSchema.shape.span_parents,
  root_span_id: projectLogsEventBaseSchema.shape.root_span_id,
  span_attributes: projectLogsEventBaseSchema.shape.span_attributes
}).openapi("ProjectLogsEvent");
var isMergeDescription = [
  "The `_is_merge` field controls how the row is merged with any existing row with the same id in the DB. By default (or when set to `false`), the existing row is completely replaced by the new row. When set to `true`, the new row is deep-merged into the existing row",
  'For example, say there is an existing row in the DB `{"id": "foo", "input": {"a": 5, "b": 10}}`. If we merge a new row as `{"_is_merge": true, "id": "foo", "input": {"b": 11, "c": 20}}`, the new row will be `{"id": "foo", "input": {"a": 5, "b": 11, "c": 20}}`. If we replace the new row as `{"id": "foo", "input": {"b": 11, "c": 20}}`, the new row will be `{"id": "foo", "input": {"b": 11, "c": 20}}`'
].join("\n\n");
var mergeEventSchema = z10.object({
  [IS_MERGE_FIELD]: customTypes.literalTrue.describe(isMergeDescription),
  [MERGE_PATHS_FIELD]: z10.string().array().array().nullish().describe(
    [
      "The `_merge_paths` field allows controlling the depth of the merge. It can only be specified alongside `_is_merge=true`. `_merge_paths` is a list of paths, where each path is a list of field names. The deep merge will not descend below any of the specified merge paths.",
      'For example, say there is an existing row in the DB `{"id": "foo", "input": {"a": {"b": 10}, "c": {"d": 20}}, "output": {"a": 20}}`. If we merge a new row as `{"_is_merge": true, "_merge_paths": [["input", "a"], ["output"]], "input": {"a": {"q": 30}, "c": {"e": 30}, "bar": "baz"}, "output": {"d": 40}}`, the new row will be `{"id": "foo": "input": {"a": {"q": 30}, "c": {"d": 20, "e": 30}, "bar": "baz"}, "output": {"d": 40}}`. In this case, due to the merge paths, we have replaced `input.a` and `output`, but have still deep-merged `input` and `input.c`.'
    ].join("\n\n")
  )
});
var replacementEventSchema = z10.object({
  [IS_MERGE_FIELD]: customTypes.literalFalse.nullish().describe(isMergeDescription),
  [PARENT_ID_FIELD]: z10.string().nullish().describe(
    [
      "Use the `_parent_id` field to create this row as a subspan of an existing row. It cannot be specified alongside `_is_merge=true`. Tracking hierarchical relationships are important for tracing (see the [guide](https://www.braintrust.dev/docs/guides/tracing) for full details).",
      'For example, say we have logged a row `{"id": "abc", "input": "foo", "output": "bar", "expected": "boo", "scores": {"correctness": 0.33}}`. We can create a sub-span of the parent row by logging `{"_parent_id": "abc", "id": "llm_call", "input": {"prompt": "What comes after foo?"}, "output": "bar", "metrics": {"tokens": 1}}`. In the webapp, only the root span row `"abc"` will show up in the summary view. You can view the full trace hierarchy (in this case, the `"llm_call"` row) by clicking on the "abc" row.'
    ].join("\n\n")
  )
});
function makeInsertEventSchemas(objectType, insertSchema) {
  const eventDescription = getEventObjectDescription(objectType);
  const article = getObjectArticle(objectType);
  const eventSchemaName = capitalize(
    getEventObjectType(objectType),
    "_"
  ).replace("_", "");
  const replaceVariantSchema = insertSchema.merge(replacementEventSchema).openapi(`Insert${eventSchemaName}EventReplace`);
  const mergeVariantSchema = insertSchema.merge(mergeEventSchema).openapi(`Insert${eventSchemaName}EventMerge`);
  const eventSchema = z10.union([replaceVariantSchema, mergeVariantSchema]).describe(`${capitalize(article)} ${eventDescription} event`).openapi(`Insert${eventSchemaName}Event`);
  const requestSchema = z10.object({
    events: eventSchema.array().describe(`A list of ${eventDescription} events to insert`)
  }).openapi(`Insert${eventSchemaName}EventRequest`);
  return { eventSchema, requestSchema };
}
var insertEventsResponseSchema = z10.object({
  row_ids: z10.string().array().describe(
    "The ids of all rows that were inserted, aligning one-to-one with the rows provided as input"
  )
}).openapi("InsertEventsResponse");
var {
  eventSchema: insertExperimentEventSchema,
  requestSchema: insertExperimentEventsRequestSchema
} = makeInsertEventSchemas(
  "experiment",
  z10.object({
    input: experimentEventSchema.shape.input,
    output: experimentEventSchema.shape.output,
    expected: experimentEventSchema.shape.expected,
    scores: experimentEventSchema.shape.scores,
    metadata: experimentEventSchema.shape.metadata,
    tags: experimentEventSchema.shape.tags,
    metrics: experimentEventSchema.shape.metrics,
    context: experimentEventSchema.shape.context,
    span_attributes: experimentEventSchema.shape.span_attributes,
    id: experimentEventSchema.shape.id.nullish(),
    dataset_record_id: experimentEventSchema.shape.dataset_record_id,
    [OBJECT_DELETE_FIELD]: experimentEventBaseSchema.shape[OBJECT_DELETE_FIELD],
    created: experimentEventBaseSchema.shape.created.nullish()
  })
);
var {
  eventSchema: insertDatasetEventSchema,
  requestSchema: insertDatasetEventsRequestSchema
} = makeInsertEventSchemas(
  "dataset",
  z10.object({
    input: datasetEventSchema.shape.input,
    expected: datasetEventSchema.shape.expected,
    metadata: datasetEventSchema.shape.metadata,
    tags: datasetEventSchema.shape.tags,
    id: datasetEventSchema.shape.id.nullish(),
    [OBJECT_DELETE_FIELD]: datasetEventBaseSchema.shape[OBJECT_DELETE_FIELD],
    created: experimentEventBaseSchema.shape.created.nullish()
  })
);
var {
  eventSchema: insertProjectLogsEventSchema,
  requestSchema: insertProjectLogsEventsRequestSchema
} = makeInsertEventSchemas(
  "project",
  z10.object({
    input: projectLogsEventSchema.shape.input,
    output: projectLogsEventSchema.shape.output,
    expected: projectLogsEventSchema.shape.expected,
    scores: projectLogsEventSchema.shape.scores,
    metadata: projectLogsEventSchema.shape.metadata,
    tags: projectLogsEventSchema.shape.tags,
    metrics: projectLogsEventSchema.shape.metrics,
    context: projectLogsEventSchema.shape.context,
    span_attributes: projectLogsEventSchema.shape.span_attributes,
    id: projectLogsEventSchema.shape.id.nullish(),
    [OBJECT_DELETE_FIELD]: projectLogsEventBaseSchema.shape[OBJECT_DELETE_FIELD],
    created: experimentEventBaseSchema.shape.created.nullish()
  })
);
function makeFeedbackRequestSchema(objectType, feedbackSchema) {
  const eventDescription = getEventObjectDescription(objectType);
  const eventSchemaName = capitalize(
    getEventObjectType(objectType),
    "_"
  ).replace("_", "");
  return z10.object({
    feedback: feedbackSchema.array().describe(`A list of ${eventDescription} feedback items`)
  }).openapi(`Feedback${eventSchemaName}EventRequest`);
}
var feedbackExperimentRequestBaseSchema = generateBaseEventFeedbackSchema("experiment");
var feedbackExperimentItemSchema = z10.object({
  id: feedbackExperimentRequestBaseSchema.shape.id,
  scores: feedbackExperimentRequestBaseSchema.shape.scores,
  expected: feedbackExperimentRequestBaseSchema.shape.expected,
  comment: feedbackExperimentRequestBaseSchema.shape.comment,
  metadata: feedbackExperimentRequestBaseSchema.shape.metadata,
  source: feedbackExperimentRequestBaseSchema.shape.source
}).openapi("FeedbackExperimentItem");
var feedbackExperimentRequestSchema = makeFeedbackRequestSchema(
  "experiment",
  feedbackExperimentItemSchema
);
var feedbackDatasetRequestBaseSchema = generateBaseEventFeedbackSchema("dataset");
var feedbackDatasetItemSchema = z10.object({
  id: feedbackDatasetRequestBaseSchema.shape.id,
  comment: feedbackDatasetRequestBaseSchema.shape.comment,
  metadata: feedbackDatasetRequestBaseSchema.shape.metadata,
  source: feedbackDatasetRequestBaseSchema.shape.source
}).openapi("FeedbackDatasetItem");
var feedbackDatasetRequestSchema = makeFeedbackRequestSchema(
  "dataset",
  feedbackDatasetItemSchema
);
var feedbackProjectLogsRequestBaseSchema = generateBaseEventFeedbackSchema("project");
var feedbackProjectLogsItemSchema = z10.object({
  id: feedbackProjectLogsRequestBaseSchema.shape.id,
  scores: feedbackProjectLogsRequestBaseSchema.shape.scores,
  expected: feedbackProjectLogsRequestBaseSchema.shape.expected,
  comment: feedbackProjectLogsRequestBaseSchema.shape.comment,
  metadata: feedbackProjectLogsRequestBaseSchema.shape.metadata,
  source: feedbackProjectLogsRequestBaseSchema.shape.source
}).openapi("FeedbackProjectLogsItem");
var feedbackProjectLogsRequestSchema = makeFeedbackRequestSchema(
  "project",
  feedbackProjectLogsItemSchema
);
var feedbackPromptRequestBaseSchema = generateBaseEventFeedbackSchema("prompt");
var feedbackPromptItemSchema = z10.object({
  id: feedbackPromptRequestBaseSchema.shape.id,
  comment: feedbackPromptRequestBaseSchema.shape.comment,
  metadata: feedbackPromptRequestBaseSchema.shape.metadata,
  source: feedbackPromptRequestBaseSchema.shape.source
}).openapi("FeedbackPromptItem");
var feedbackPromptRequestSchema = makeFeedbackRequestSchema(
  "prompt",
  feedbackPromptItemSchema
);
var feedbackFunctionRequestBaseSchema = generateBaseEventFeedbackSchema("function");
var feedbackFunctionItemSchema = z10.object({
  id: feedbackFunctionRequestBaseSchema.shape.id,
  comment: feedbackFunctionRequestBaseSchema.shape.comment,
  metadata: feedbackFunctionRequestBaseSchema.shape.metadata,
  source: feedbackFunctionRequestBaseSchema.shape.source
}).openapi("FeedbackFunctionItem");
var feedbackFunctionRequestSchema = makeFeedbackRequestSchema(
  "function",
  feedbackFunctionItemSchema
);
var apiSpecEventObjectSchemas = {
  experiment: {
    event: experimentEventSchema,
    fetchResponse: makeFetchEventsResponseSchema(
      "experiment",
      experimentEventSchema
    ),
    insertEvent: insertExperimentEventSchema,
    insertRequest: insertExperimentEventsRequestSchema,
    feedbackItem: feedbackExperimentItemSchema,
    feedbackRequest: feedbackExperimentRequestSchema
  },
  dataset: {
    event: datasetEventSchema,
    fetchResponse: makeFetchEventsResponseSchema("dataset", datasetEventSchema),
    insertEvent: insertDatasetEventSchema,
    insertRequest: insertDatasetEventsRequestSchema,
    feedbackItem: feedbackDatasetItemSchema,
    feedbackRequest: feedbackDatasetRequestSchema
  },
  project_logs: {
    event: projectLogsEventSchema,
    fetchResponse: makeFetchEventsResponseSchema(
      "project",
      projectLogsEventSchema
    ),
    insertEvent: insertProjectLogsEventSchema,
    insertRequest: insertProjectLogsEventsRequestSchema,
    feedbackItem: feedbackProjectLogsItemSchema,
    feedbackRequest: feedbackProjectLogsRequestSchema
  },
  prompt: {
    event: promptSchema,
    feedbackItem: feedbackPromptItemSchema,
    feedbackRequest: feedbackPromptRequestSchema
  },
  function: {
    event: functionSchema2,
    feedbackItem: feedbackFunctionItemSchema,
    feedbackRequest: feedbackFunctionRequestSchema
  },
  prompt_session: {}
};
function makeCrossObjectIndividualRequestSchema(objectType) {
  const eventObjectType = getEventObjectType(objectType);
  const eventDescription = getEventObjectDescription(objectType);
  const eventObjectSchema = apiSpecEventObjectSchemas[eventObjectType];
  const insertObject = z10.object({
    ...eventObjectSchema.insertEvent ? {
      events: eventObjectSchema.insertEvent.array().nullish().describe(`A list of ${eventDescription} events to insert`)
    } : {},
    ...eventObjectSchema.feedbackItem ? {
      feedback: eventObjectSchema.feedbackItem.array().nullish().describe(`A list of ${eventDescription} feedback items`)
    } : {}
  });
  return z10.record(z10.string().uuid(), insertObject).nullish().describe(
    `A mapping from ${objectType} id to a set of log events and feedback items to insert`
  );
}
function makeCrossObjectIndividualResponseSchema(objectType) {
  return z10.record(z10.string().uuid(), insertEventsResponseSchema).nullish().describe(
    `A mapping from ${objectType} id to row ids for inserted \`events\``
  );
}
var crossObjectInsertRequestSchema = z10.object({
  experiment: makeCrossObjectIndividualRequestSchema("experiment"),
  dataset: makeCrossObjectIndividualRequestSchema("dataset"),
  project_logs: makeCrossObjectIndividualRequestSchema("project")
}).openapi("CrossObjectInsertRequest");
var crossObjectInsertResponseSchema = z10.object({
  experiment: makeCrossObjectIndividualResponseSchema("experiment"),
  dataset: makeCrossObjectIndividualResponseSchema("dataset"),
  project_logs: makeCrossObjectIndividualResponseSchema("project")
}).openapi("CrossObjectInsertResponse");
var summarizeScoresParamSchema = z10.boolean().describe(
  "Whether to summarize the scores and metrics. If false (or omitted), only the metadata will be returned."
);
var comparisonExperimentIdParamSchema = z10.string().uuid().describe(
  "The experiment to compare against, if summarizing scores and metrics. If omitted, will fall back to the `base_exp_id` stored in the experiment metadata, and then to the most recent experiment run in the same project. Must pass `summarize_scores=true` for this id to be used"
);
var summarizeDataParamSchema = z10.boolean().describe(
  "Whether to summarize the data. If false (or omitted), only the metadata will be returned."
);
var summarizeExperimentResponseSchema = z10.object({
  project_name: z10.string().describe("Name of the project that the experiment belongs to"),
  experiment_name: z10.string().describe("Name of the experiment"),
  project_url: z10.string().url().describe("URL to the project's page in the Braintrust app"),
  experiment_url: z10.string().url().describe("URL to the experiment's page in the Braintrust app"),
  comparison_experiment_name: z10.string().nullish().describe("The experiment which scores are baselined against"),
  scores: z10.record(
    z10.object({
      name: z10.string().describe("Name of the score"),
      score: z10.number().min(0).max(1).describe("Average score across all examples"),
      diff: z10.number().min(-1).max(1).optional().describe(
        "Difference in score between the current and comparison experiment"
      ),
      improvements: z10.number().int().min(0).describe("Number of improvements in the score"),
      regressions: z10.number().int().min(0).describe("Number of regressions in the score")
    }).describe("Summary of a score's performance").openapi("ScoreSummary")
  ).nullish().describe("Summary of the experiment's scores"),
  metrics: z10.record(
    z10.object({
      name: z10.string().describe("Name of the metric"),
      metric: z10.number().describe("Average metric across all examples"),
      unit: z10.string().describe("Unit label for the metric"),
      diff: z10.number().optional().describe(
        "Difference in metric between the current and comparison experiment"
      ),
      improvements: z10.number().int().min(0).describe("Number of improvements in the metric"),
      regressions: z10.number().int().min(0).describe("Number of regressions in the metric")
    }).describe("Summary of a metric's performance").openapi("MetricSummary")
  ).nullish().describe("Summary of the experiment's metrics")
}).describe("Summary of an experiment").openapi("SummarizeExperimentResponse");
var summarizeDatasetResponseSchema = z10.object({
  project_name: z10.string().describe("Name of the project that the dataset belongs to"),
  dataset_name: z10.string().describe("Name of the dataset"),
  project_url: z10.string().url().describe("URL to the project's page in the Braintrust app"),
  dataset_url: z10.string().url().describe("URL to the dataset's page in the Braintrust app"),
  data_summary: z10.object({
    total_records: z10.number().int().min(0).describe("Total number of records in the dataset")
  }).nullish().describe("Summary of a dataset's data").openapi("DataSummary")
}).describe("Summary of a dataset").openapi("SummarizeDatasetResponse");

// typespecs/functions.ts
import { z as z11 } from "zod";
var INVOKE_API_VERSION = 1;
var functionIdSchema = z11.union([
  z11.object({
    function_id: z11.string().describe("The ID of the function."),
    version: z11.string().optional().describe("The version of the function.")
  }),
  z11.object({
    project_name: z11.string().describe("The name of the project containing the function."),
    slug: z11.string().describe("The slug of the function."),
    version: z11.string().optional().describe("The version of the function.")
  }),
  z11.object({
    global_function: z11.string().describe(
      "The name of the global function. Currently, the global namespace includes the functions in autoevals."
    )
  }),
  z11.object({
    prompt_session_id: z11.string().describe("The ID of the prompt session."),
    prompt_session_function_id: z11.string().describe("The ID of the function in the prompt session."),
    version: z11.string().optional().describe("The version of the function.")
  })
]);
var useFunctionSchema = z11.object({
  api_version: z11.number().optional().default(INVOKE_API_VERSION)
}).and(functionIdSchema);
var invokeFunctionSchema = useFunctionSchema.and(
  z11.object({
    input: z11.any().optional(),
    parent: z11.string().optional(),
    stream: z11.boolean().optional()
  })
);
var baseSSEEventSchema = z11.object({
  id: z11.string().optional(),
  data: z11.string()
});
var sseTextEventSchema = baseSSEEventSchema.merge(
  z11.object({
    event: z11.literal("text_delta")
  })
);
var sseDataEventSchema = baseSSEEventSchema.merge(
  z11.object({
    event: z11.literal("json_delta")
  })
);
var sseDoneEventSchema = baseSSEEventSchema.omit({ data: true }).merge(
  z11.object({
    event: z11.literal("done"),
    data: z11.literal("")
  })
);
var callEventSchema = z11.union([
  sseTextEventSchema,
  sseDataEventSchema,
  sseDoneEventSchema
]);

// src/git_fields.ts
import { z as z12 } from "zod";
var gitFieldsSchema = repoInfoSchema.keyof();
var collectMetadataEnum = z12.enum(["all", "none", "some"]);
var gitMetadataSettingsSchema = z12.strictObject({
  collect: collectMetadataEnum,
  fields: z12.array(gitFieldsSchema).optional()
});
function mergeGitMetadataSettings(s1, s2) {
  var _a2;
  if (s1.collect === "all") {
    return s2;
  } else if (s2.collect === "all") {
    return s1;
  } else if (s1.collect === "none") {
    return s1;
  } else if (s2.collect === "none") {
    return s2;
  }
  const fields = ((_a2 = s1.fields) != null ? _a2 : []).filter((f) => {
    var _a3;
    return ((_a3 = s2.fields) != null ? _a3 : []).includes(f);
  });
  const collect = fields.length > 0 ? "some" : "none";
  return { collect, fields };
}

// src/xact-ids.ts
var TOP_BITS = BigInt("0x0DE1") << BigInt(48);
var MOD = BigInt(1) << BigInt(64);
var COPRIME = BigInt("205891132094649");
var COPRIME_INVERSE = BigInt("1522336535492693385");
function modularMultiply(value, prime) {
  return value * prime % MOD;
}
function prettifyXact(valueString) {
  const value = BigInt(valueString);
  const encoded = modularMultiply(value, COPRIME);
  return encoded.toString(16).padStart(16, "0");
}
function loadPrettyXact(encodedHex) {
  const value = BigInt(`0x${encodedHex}`);
  const multipliedInverse = modularMultiply(value, COPRIME_INVERSE);
  const withTopBits = TOP_BITS | multipliedInverse;
  return withTopBits.toString();
}

// src/zod_util.ts
function parseNoStrip(schema, input) {
  const output = schema.parse(input);
  forEachMissingKey({
    lhs: output,
    rhs: input,
    fn: ({ k, path }) => {
      throw new Error(
        `Extraneous key ${JSON.stringify(k)} at path ${JSON.stringify(
          path
        )} in input`
      );
    }
  });
  return output;
}
export {
  ALL_ROW_ID_FIELDS,
  AUDIT_METADATA_FIELD,
  AUDIT_SOURCE_FIELD,
  BT_CURSOR_HEADER,
  BT_FOUND_EXISTING_HEADER,
  BT_IMPERSONATE_USER,
  CREATED_FIELD,
  DEFAULT_IS_LEGACY_DATASET,
  ID_FIELD,
  IS_MERGE_FIELD,
  MERGE_PATHS_FIELD,
  OBJECT_DELETE_FIELD,
  PARENT_ID_FIELD,
  SpanComponentsV1,
  SpanComponentsV2,
  SpanObjectTypeV1,
  SpanObjectTypeV2,
  SpanRowIdsV1,
  SpanRowIdsV2,
  SpanTypeAttribute,
  TRANSACTION_ID_FIELD,
  VALID_SOURCES,
  _urljoin,
  batchItems,
  capitalize,
  constructJsonArray,
  ensureDatasetRecord,
  ensureLegacyDatasetRecord,
  ensureNewDatasetRecord,
  forEachMissingKey,
  gitFieldsSchema,
  gitMetadataSettingsSchema,
  loadPrettyXact,
  makeLegacyEvent,
  mapAt,
  mergeDicts,
  mergeGitMetadataSettings,
  mergeRowBatch,
  parseNoStrip,
  prettifyXact,
  snakeToCamelCase,
  snakeToTitleCase,
  spanTypeAttributeValues
};
