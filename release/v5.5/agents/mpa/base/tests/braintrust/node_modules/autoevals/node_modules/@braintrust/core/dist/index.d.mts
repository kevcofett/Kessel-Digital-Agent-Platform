import { z } from 'zod';

declare const TRANSACTION_ID_FIELD = "_xact_id";
declare const OBJECT_DELETE_FIELD = "_object_delete";
declare const CREATED_FIELD = "created";
declare const ID_FIELD = "id";
declare const IS_MERGE_FIELD = "_is_merge";
declare const MERGE_PATHS_FIELD = "_merge_paths";
declare const AUDIT_SOURCE_FIELD = "_audit_source";
declare const AUDIT_METADATA_FIELD = "_audit_metadata";
declare const VALID_SOURCES: readonly ["app", "api", "external"];
type Source = (typeof VALID_SOURCES)[number];
declare const PARENT_ID_FIELD = "_parent_id";
type TransactionId = string;
declare const ALL_ROW_ID_FIELDS: string[];

declare const BT_FOUND_EXISTING_HEADER = "x-bt-found-existing";
declare const BT_CURSOR_HEADER = "x-bt-cursor";
declare const BT_IMPERSONATE_USER = "x-bt-impersonate-user";

declare function mergeRowBatch<T extends {
    id: string;
    [IS_MERGE_FIELD]?: boolean;
    [PARENT_ID_FIELD]?: string;
}>(rows: T[]): T[][];
declare function batchItems(args: {
    items: string[][];
    batchMaxNumItems?: number;
    batchMaxNumBytes?: number;
}): string[][][];

type IdField = {
    id: string;
};
type InputField = {
    input: unknown;
};
type InputsField = {
    inputs: unknown;
};
type OtherExperimentLogFields = {
    output: unknown;
    expected: unknown;
    tags: string[];
    scores: Record<string, number | null>;
    metadata: Record<string, unknown>;
    metrics: Record<string, unknown>;
    datasetRecordId: string;
};
type ExperimentLogPartialArgs = Partial<OtherExperimentLogFields> & Partial<InputField | InputsField>;
type ExperimentLogFullArgs = Partial<Omit<OtherExperimentLogFields, "output" | "scores">> & Required<Pick<OtherExperimentLogFields, "output" | "scores">> & Partial<InputField | InputsField> & Partial<IdField>;
type LogFeedbackFullArgs = IdField & Partial<Omit<OtherExperimentLogFields, "output" | "metrics" | "datasetRecordId"> & {
    comment: string;
    source: Source;
}>;
interface ParentExperimentIds {
    experiment_id: string;
}
interface ParentProjectLogIds {
    project_id: string;
    log_id: "g";
}
type LogCommentFullArgs = IdField & {
    created: string;
    origin: {
        id: string;
    };
    comment: {
        text: string;
    };
    [AUDIT_SOURCE_FIELD]: Source;
    [AUDIT_METADATA_FIELD]?: Record<string, unknown>;
} & (ParentExperimentIds | ParentProjectLogIds);
type SanitizedExperimentLogPartialArgs = Partial<OtherExperimentLogFields> & Partial<InputField>;
type ExperimentEvent = Partial<InputField> & Partial<OtherExperimentLogFields> & {
    id: string;
    span_id?: string;
    root_span_id?: string;
    experiment_id: string;
    [IS_MERGE_FIELD]: boolean;
} & Partial<{
    created: string;
    span_parents: string[];
    span_attributes: Record<string, unknown>;
    context: Record<string, unknown>;
    [PARENT_ID_FIELD]: string;
    [AUDIT_SOURCE_FIELD]: Source;
    [AUDIT_METADATA_FIELD]?: Record<string, unknown>;
}>;
type DatasetEvent = {
    input?: unknown;
    tags?: string[];
    metadata?: unknown;
    id: string;
    dataset_id: string;
    created: string;
} & ({
    expected?: unknown;
} | {
    output?: unknown;
});
type LoggingEvent = Omit<ExperimentEvent, "experiment_id"> & {
    project_id: string;
    log_id: "g";
};
type CommentEvent = IdField & {
    created: string;
    origin: {
        id: string;
    };
    comment: {
        text: string;
    };
    [AUDIT_SOURCE_FIELD]: Source;
    [AUDIT_METADATA_FIELD]?: Record<string, unknown>;
} & (ParentExperimentIds | ParentProjectLogIds);
type BackgroundLogEvent = ExperimentEvent | DatasetEvent | LoggingEvent | CommentEvent;
declare const DEFAULT_IS_LEGACY_DATASET = false;
interface LegacyDatasetRecord {
    id: string;
    input: any;
    output: any;
    metadata: any;
}
interface NewDatasetRecord {
    id: string;
    input: any;
    expected: any;
    tags: any;
    metadata: any;
}
type DatasetRecord<IsLegacyDataset extends boolean = typeof DEFAULT_IS_LEGACY_DATASET> = IsLegacyDataset extends true ? LegacyDatasetRecord : NewDatasetRecord;
type AnyDatasetRecord = DatasetRecord<boolean>;
declare function ensureDatasetRecord<IsLegacyDataset extends boolean = typeof DEFAULT_IS_LEGACY_DATASET>(r: AnyDatasetRecord, legacy: IsLegacyDataset): DatasetRecord<IsLegacyDataset>;
declare function ensureLegacyDatasetRecord(r: AnyDatasetRecord): DatasetRecord<true>;
declare function ensureNewDatasetRecord(r: AnyDatasetRecord): DatasetRecord<false>;
declare function makeLegacyEvent(e: BackgroundLogEvent): BackgroundLogEvent;

interface Score {
    name: string;
    score: number | null;
    metadata?: Record<string, unknown>;
    /**
     * @deprecated
     */
    error?: unknown;
}
type ScorerArgs<Output, Extra> = {
    output: Output;
    expected?: Output;
} & Extra;
type Scorer<Output, Extra> = (args: ScorerArgs<Output, Extra>) => Score | Promise<Score>;

declare function mergeDicts(mergeInto: Record<string, unknown>, mergeFrom: Record<string, unknown>): Record<string, unknown>;
declare function forEachMissingKey({ lhs, rhs, fn, }: {
    lhs: unknown;
    rhs: unknown;
    fn: (args: {
        lhs: Record<string, unknown>;
        k: string;
        v: unknown;
        path: string[];
    }) => void;
}): void;
declare function capitalize(s: string, sep?: string): string;
declare function snakeToCamelCase(s: string): string;
declare function snakeToTitleCase(s: string): string;
declare function constructJsonArray(items: string[]): string;
declare function mapAt<K, V>(m: Map<K, V>, k: K): V;
declare function _urljoin(...parts: string[]): string;

declare enum SpanObjectTypeV1 {
    EXPERIMENT = 1,
    PROJECT_LOGS = 2
}
declare class SpanRowIdsV1 {
    rowId: string;
    spanId: string;
    rootSpanId: string;
    constructor(args: {
        rowId: string;
        spanId: string;
        rootSpanId: string;
    });
    toObject(): {
        rowId: string;
        spanId: string;
        rootSpanId: string;
    };
}
declare class SpanComponentsV1 {
    objectType: SpanObjectTypeV1;
    objectId: string;
    rowIds: SpanRowIdsV1 | undefined;
    constructor(args: {
        objectType: SpanObjectTypeV1;
        objectId: string;
        rowIds?: SpanRowIdsV1;
    });
    toStr(): string;
    static fromStr(s: string): SpanComponentsV1;
    objectIdFields(): ParentExperimentIds | ParentProjectLogIds;
    toObject(): {
        objectType: SpanObjectTypeV1;
        objectId: string;
        rowIds: {
            rowId: string;
            spanId: string;
            rootSpanId: string;
        } | undefined;
    };
}

declare enum SpanObjectTypeV2 {
    EXPERIMENT = 1,
    PROJECT_LOGS = 2
}
declare class SpanRowIdsV2 {
    rowId: string;
    spanId: string;
    rootSpanId: string;
    constructor(args: {
        rowId: string;
        spanId: string;
        rootSpanId: string;
    });
    toObject(): {
        rowId: string;
        spanId: string;
        rootSpanId: string;
    };
}
declare class SpanComponentsV2 {
    objectType: SpanObjectTypeV2;
    objectId: string | undefined;
    computeObjectMetadataArgs: Record<string, any> | undefined;
    rowIds: SpanRowIdsV2 | undefined;
    constructor(args: {
        objectType: SpanObjectTypeV2;
        objectId?: string;
        computeObjectMetadataArgs?: Record<string, any>;
        rowIds?: SpanRowIdsV2;
    });
    toStr(): string;
    static fromStr(s: string): SpanComponentsV2;
    objectIdFields(): ParentExperimentIds | ParentProjectLogIds;
    toObject(): {
        objectType: SpanObjectTypeV2;
        objectId: string | undefined;
        computeObjectMetadataArgs: Record<string, any> | undefined;
        rowIds: {
            rowId: string;
            spanId: string;
            rootSpanId: string;
        } | undefined;
    };
}

declare const spanTypeAttributeValues: readonly ["llm", "score", "function", "eval", "task", "tool"];
declare enum SpanTypeAttribute {
    LLM = "llm",
    SCORE = "score",
    FUNCTION = "function",
    EVAL = "eval",
    TASK = "task",
    TOOL = "tool"
}
type SpanType = (typeof spanTypeAttributeValues)[number];

declare const repoInfoSchema: z.ZodObject<{
    commit: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    branch: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    tag: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    dirty: z.ZodOptional<z.ZodNullable<z.ZodBoolean>>;
    author_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    author_email: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    commit_message: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    commit_time: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    git_diff: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    commit?: string | null | undefined;
    branch?: string | null | undefined;
    tag?: string | null | undefined;
    dirty?: boolean | null | undefined;
    author_name?: string | null | undefined;
    author_email?: string | null | undefined;
    commit_message?: string | null | undefined;
    commit_time?: string | null | undefined;
    git_diff?: string | null | undefined;
}, {
    commit?: string | null | undefined;
    branch?: string | null | undefined;
    tag?: string | null | undefined;
    dirty?: boolean | null | undefined;
    author_name?: string | null | undefined;
    author_email?: string | null | undefined;
    commit_message?: string | null | undefined;
    commit_time?: string | null | undefined;
    git_diff?: string | null | undefined;
}>;

type RepoInfo = z.infer<typeof repoInfoSchema>;
declare const gitFieldsSchema: z.ZodEnum<["dirty", "tag", "commit", "branch", "author_name", "author_email", "commit_message", "commit_time", "git_diff"]>;
type GitFields = z.infer<typeof gitFieldsSchema>;
declare const collectMetadataEnum: z.ZodEnum<["all", "none", "some"]>;
type CollectMetadata = z.infer<typeof collectMetadataEnum>;
declare const gitMetadataSettingsSchema: z.ZodObject<{
    collect: z.ZodEnum<["all", "none", "some"]>;
    fields: z.ZodOptional<z.ZodArray<z.ZodEnum<["dirty", "tag", "commit", "branch", "author_name", "author_email", "commit_message", "commit_time", "git_diff"]>, "many">>;
}, "strict", z.ZodTypeAny, {
    collect: "some" | "none" | "all";
    fields?: ("dirty" | "tag" | "commit" | "branch" | "author_name" | "author_email" | "commit_message" | "commit_time" | "git_diff")[] | undefined;
}, {
    collect: "some" | "none" | "all";
    fields?: ("dirty" | "tag" | "commit" | "branch" | "author_name" | "author_email" | "commit_message" | "commit_time" | "git_diff")[] | undefined;
}>;
type GitMetadataSettings = z.infer<typeof gitMetadataSettingsSchema>;
declare function mergeGitMetadataSettings(s1: GitMetadataSettings, s2: GitMetadataSettings): GitMetadataSettings;

declare function prettifyXact(valueString: TransactionId): string;
declare function loadPrettyXact(encodedHex: string): TransactionId;

declare function parseNoStrip<T extends z.ZodType>(schema: T, input: unknown): z.TypeOf<T>;

export { ALL_ROW_ID_FIELDS, AUDIT_METADATA_FIELD, AUDIT_SOURCE_FIELD, type AnyDatasetRecord, BT_CURSOR_HEADER, BT_FOUND_EXISTING_HEADER, BT_IMPERSONATE_USER, type BackgroundLogEvent, CREATED_FIELD, type CollectMetadata, type CommentEvent, DEFAULT_IS_LEGACY_DATASET, type DatasetEvent, type DatasetRecord, type ExperimentEvent, type ExperimentLogFullArgs, type ExperimentLogPartialArgs, type GitFields, type GitMetadataSettings, ID_FIELD, IS_MERGE_FIELD, type IdField, type InputField, type InputsField, type LogCommentFullArgs, type LogFeedbackFullArgs, type LoggingEvent, MERGE_PATHS_FIELD, OBJECT_DELETE_FIELD, type OtherExperimentLogFields, PARENT_ID_FIELD, type ParentExperimentIds, type ParentProjectLogIds, type RepoInfo, type SanitizedExperimentLogPartialArgs, type Score, type Scorer, type ScorerArgs, type Source, SpanComponentsV1, SpanComponentsV2, SpanObjectTypeV1, SpanObjectTypeV2, SpanRowIdsV1, SpanRowIdsV2, type SpanType, SpanTypeAttribute, TRANSACTION_ID_FIELD, type TransactionId, VALID_SOURCES, _urljoin, batchItems, capitalize, constructJsonArray, ensureDatasetRecord, ensureLegacyDatasetRecord, ensureNewDatasetRecord, forEachMissingKey, gitFieldsSchema, gitMetadataSettingsSchema, loadPrettyXact, makeLegacyEvent, mapAt, mergeDicts, mergeGitMetadataSettings, mergeRowBatch, parseNoStrip, prettifyXact, snakeToCamelCase, snakeToTitleCase, spanTypeAttributeValues };
