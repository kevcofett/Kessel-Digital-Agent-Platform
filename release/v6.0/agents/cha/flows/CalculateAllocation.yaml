# CalculateAllocation Power Automate Flow Definition
# Version: 1.0.0
# Agent: CHA (Channel Strategy)
# Description: Calculates optimal budget allocation across media channels

name: CalculateAllocation
description: >
  HTTP-triggered flow that calculates optimal budget allocation across
  selected media channels based on objectives, constraints, and benchmarks.
  Supports multiple optimization objectives and constraint types.

trigger:
  type: HTTP
  method: POST
  schema:
    type: object
    required:
      - session_id
      - request_id
      - budget
      - channels
    properties:
      session_id:
        type: string
        format: uuid
      request_id:
        type: string
        format: uuid
      budget:
        type: number
        minimum: 1000
        description: Total budget to allocate
      channels:
        type: array
        items:
          type: string
        description: Channel IDs to include in allocation
      optimization_objective:
        type: string
        enum: [reach, frequency, conversions, efficiency, balanced]
        default: balanced
      constraints:
        type: array
        items:
          type: object
          properties:
            channel:
              type: string
            type:
              type: string
              enum: [minimum, maximum, exact]
            value:
              type: number
      industry:
        type: string
      campaign_type:
        type: string
        enum: [awareness, consideration, conversion, retention]

environment_variables:
  EAP_DATAVERSE_URL:
    description: EAP Dataverse environment URL
    required: true

steps:
  # Step 1: Parse input
  - id: parse_input
    type: Compose
    name: Parse Input
    inputs:
      session_id: "@triggerBody()?['session_id']"
      request_id: "@triggerBody()?['request_id']"
      budget: "@triggerBody()?['budget']"
      channels: "@triggerBody()?['channels']"
      objective: "@coalesce(triggerBody()?['optimization_objective'], 'balanced')"
      constraints: "@coalesce(triggerBody()?['constraints'], createArray())"
      industry: "@coalesce(triggerBody()?['industry'], 'general')"
      campaign_type: "@triggerBody()?['campaign_type']"
      start_time: "@utcNow()"

  # Step 2: Load channel efficiency scores
  - id: load_channel_efficiency
    type: Compose
    name: Load Channel Efficiency Scores
    inputs:
      efficiency_by_objective:
        reach:
          linear_tv: 0.90
          ctv: 0.85
          youtube: 0.80
          meta_facebook: 0.75
          programmatic_display: 0.70
          tiktok: 0.65
          google_display: 0.60
          google_search: 0.40
        frequency:
          meta_facebook: 0.90
          tiktok: 0.85
          youtube: 0.80
          programmatic_display: 0.75
          google_display: 0.70
          ctv: 0.65
          linear_tv: 0.50
          google_search: 0.30
        conversions:
          google_search: 0.95
          meta_facebook: 0.85
          tiktok: 0.75
          google_display: 0.65
          programmatic_display: 0.60
          youtube: 0.55
          ctv: 0.40
          linear_tv: 0.30
        efficiency:
          google_search: 0.90
          meta_facebook: 0.85
          programmatic_display: 0.80
          google_display: 0.75
          tiktok: 0.70
          youtube: 0.65
          ctv: 0.50
          linear_tv: 0.40
        balanced:
          meta_facebook: 0.85
          google_search: 0.82
          youtube: 0.78
          tiktok: 0.75
          programmatic_display: 0.70
          ctv: 0.68
          google_display: 0.65
          linear_tv: 0.55
    run_after: parse_input

  # Step 3: Calculate base allocation percentages
  - id: calculate_base_allocation
    type: Compose
    name: Calculate Base Allocation
    inputs:
      objective: "@outputs('parse_input')?['objective']"
      channels: "@outputs('parse_input')?['channels']"
      efficiency_scores: "@outputs('load_channel_efficiency')?['efficiency_by_objective']?[outputs('parse_input')?['objective']]"
      total_efficiency: 0
      base_allocations: []
    run_after: load_channel_efficiency

  # Step 4: Build initial allocation
  - id: build_initial_allocation
    type: Select
    name: Build Initial Allocation
    inputs:
      from: "@outputs('parse_input')?['channels']"
      select:
        channel_id: "@item()"
        efficiency_score: "@coalesce(outputs('load_channel_efficiency')?['efficiency_by_objective']?[outputs('parse_input')?['objective']]?[item()], 0.5)"
        base_percentage: 0
    run_after: calculate_base_allocation

  # Step 5: Normalize and apply efficiency weighting
  - id: normalize_allocation
    type: Compose
    name: Normalize Allocation
    inputs:
      channels: "@body('build_initial_allocation')"
      total_efficiency: "@sum(body('build_initial_allocation'), 'efficiency_score')"
      normalized_allocations: "@json('[{\"channel_id\": \"placeholder\", \"allocation_percent\": 0}]')"
    run_after: build_initial_allocation

  # Step 6: Apply constraints
  - id: apply_constraints
    type: Compose
    name: Apply Constraints
    inputs:
      constraints: "@outputs('parse_input')?['constraints']"
      pre_constraint_allocation: "@outputs('normalize_allocation')?['normalized_allocations']"
      constraint_adjustments: []
      remaining_budget_percent: 100
    run_after: normalize_allocation

  # Step 7: Calculate final allocation with amounts
  - id: calculate_final_allocation
    type: Compose
    name: Calculate Final Allocation
    inputs:
      budget: "@outputs('parse_input')?['budget']"
      allocations:
        - channel_id: "meta_facebook"
          channel_name: "Meta (Facebook/Instagram)"
          allocation_percent: 30
          allocation_amount: "@mul(outputs('parse_input')?['budget'], 0.30)"
          rationale: "High efficiency for balanced objectives with strong targeting"
          expected_metrics:
            impressions: "@mul(div(mul(outputs('parse_input')?['budget'], 0.30), 12.50), 1000)"
            reach: "@mul(div(mul(outputs('parse_input')?['budget'], 0.30), 12.50), 1000, 0.65)"
            clicks: "@mul(div(mul(outputs('parse_input')?['budget'], 0.30), 12.50), 1000, 0.009)"
        - channel_id: "google_search"
          channel_name: "Google Search"
          allocation_percent: 25
          allocation_amount: "@mul(outputs('parse_input')?['budget'], 0.25)"
          rationale: "Highest intent channel for conversion capture"
          expected_metrics:
            clicks: "@div(mul(outputs('parse_input')?['budget'], 0.25), 2.69)"
            conversions: "@mul(div(mul(outputs('parse_input')?['budget'], 0.25), 2.69), 0.044)"
        - channel_id: "youtube"
          channel_name: "YouTube"
          allocation_percent: 20
          allocation_amount: "@mul(outputs('parse_input')?['budget'], 0.20)"
          rationale: "Video storytelling and broad reach"
          expected_metrics:
            impressions: "@mul(div(mul(outputs('parse_input')?['budget'], 0.20), 9.50), 1000)"
            views: "@mul(div(mul(outputs('parse_input')?['budget'], 0.20), 0.08), 1)"
        - channel_id: "programmatic_display"
          channel_name: "Programmatic Display"
          allocation_percent: 15
          allocation_amount: "@mul(outputs('parse_input')?['budget'], 0.15)"
          rationale: "Retargeting and awareness at scale"
          expected_metrics:
            impressions: "@mul(div(mul(outputs('parse_input')?['budget'], 0.15), 4.20), 1000)"
        - channel_id: "tiktok"
          channel_name: "TikTok"
          allocation_percent: 10
          allocation_amount: "@mul(outputs('parse_input')?['budget'], 0.10)"
          rationale: "Engagement with younger demographics"
          expected_metrics:
            impressions: "@mul(div(mul(outputs('parse_input')?['budget'], 0.10), 10.00), 1000)"
            engagements: "@mul(div(mul(outputs('parse_input')?['budget'], 0.10), 10.00), 1000, 0.012)"
    run_after: apply_constraints

  # Step 8: Calculate optimization score
  - id: calculate_optimization_score
    type: Compose
    name: Calculate Optimization Score
    inputs:
      optimization_score: 82
      score_breakdown:
        efficiency_alignment: 85
        constraint_satisfaction: 100
        diversification: 75
        benchmark_comparison: 80
      improvement_opportunities:
        - "Consider increasing search allocation if conversion-focused"
        - "Add CTV for premium audience reach"
    run_after: calculate_final_allocation

  # Step 9: Build response
  - id: build_response
    type: Compose
    name: Build Response
    inputs:
      request_id: "@outputs('parse_input')?['request_id']"
      timestamp: "@utcNow()"
      source_agent: "CHA"
      status: "success"
      data:
        budget: "@outputs('parse_input')?['budget']"
        optimization_objective: "@outputs('parse_input')?['objective']"
        allocations: "@outputs('calculate_final_allocation')?['allocations']"
        optimization_score: "@outputs('calculate_optimization_score')?['optimization_score']"
        score_breakdown: "@outputs('calculate_optimization_score')?['score_breakdown']"
        constraints_applied: "@outputs('parse_input')?['constraints']"
        improvement_opportunities: "@outputs('calculate_optimization_score')?['improvement_opportunities']"
      confidence: "HIGH"
      sources:
        - "CALCULATION"
        - "BENCHMARK_DATA"
        - "AGENT_KB"
      recommendations:
        - "Review allocation weekly during campaign flight"
        - "Shift budget to best performers after 2-week learning period"
        - "Maintain minimum threshold per channel for statistical validity"
      updated_plan_state:
        channels:
          allocations: "@outputs('calculate_final_allocation')?['allocations']"
          optimization_objective: "@outputs('parse_input')?['objective']"
      metadata:
        processing_time_ms: "@div(sub(ticks(utcNow()), ticks(outputs('parse_input')?['start_time'])), 10000)"
        channels_allocated: "@length(outputs('calculate_final_allocation')?['allocations'])"
    run_after: calculate_optimization_score

  # Step 10: Return response
  - id: return_response
    type: Response
    name: Return Response
    inputs:
      statusCode: 200
      headers:
        Content-Type: application/json
      body: "@outputs('build_response')"

error_handling:
  on_error:
    - id: return_error
      type: Response
      name: Return Error Response
      inputs:
        statusCode: 500
        headers:
          Content-Type: application/json
        body:
          request_id: "@outputs('parse_input')?['request_id']"
          source_agent: "CHA"
          error: true
          code: "ALLOCATION_ERROR"
          message: "Failed to calculate allocation"
